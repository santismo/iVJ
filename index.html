<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>iVJ</title>
  <style>
    :root{
      --bg:#07080c; --panel:#0f1118; --panel2:#0b0d13;
      --text:#e9edf6; --muted:#9aa3b5; --border:rgba(255,255,255,.12);
      --accent:#7aa2ff; --radius:16px; --maxw:1200px;
    }
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    .wrap{max-width:var(--maxw);margin:16px auto;padding:0 14px;display:grid;gap:12px;}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .title{display:grid;gap:4px}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      font-size:14px;
      cursor:pointer;
    }
    button.primary{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 2px rgba(122,162,255,.10) inset;
    }
    button.danger{border-color:rgba(255,130,130,.5)}
    button:active{transform:translateY(1px)}
    .quickBar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .quickBar .pill{
      display:inline-flex;gap:8px;align-items:center;
      font-size:12px;color:var(--muted);
      border:1px solid var(--border);
      padding:6px 10px;border-radius:999px;
      background:rgba(255,255,255,.02);
    }
    .quickBtn{padding:8px 10px;font-size:12px}

    .stage{
      position:relative; width:100%; aspect-ratio:16/9;
      border-radius:var(--radius); overflow:hidden; border:1px solid var(--border);
      background:#000; isolation:isolate;
    }
    #mixStage{position:absolute; inset:0; z-index:10;}
    .layersRoot{position:absolute; inset:0; z-index:10;}
    .layer{position:absolute; inset:0; pointer-events:none; will-change:opacity,filter,transform; mix-blend-mode:normal; opacity:1;}
    .layer iframe, .layer video{width:100%;height:100%;border:0;display:block;object-fit:cover;}

    /* WebGL output canvas (capture FX overlay) */
    canvas#fxOut{
      position:absolute; inset:0; width:100%; height:100%;
      display:none;
      z-index:30;
      pointer-events:none;
    }

    /* Top-right overlay on stage (hidden unless capture active) */
    .fxHUD{
      position:absolute;
      right:10px;
      top:10px;
      z-index:60;
      display:none;
      pointer-events:auto;
      user-select:none;
    }
    .fxHUD .btn{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.28);
      color:rgba(255,255,255,.92);
      backdrop-filter: blur(8px);
      border-radius:999px;
      padding:10px 12px;
      cursor:pointer;
      font-size:13px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      opacity:.86;
      transition:opacity .15s ease, transform .15s ease;
      box-shadow:0 18px 60px rgba(0,0,0,.35);
    }
    .fxHUD .btn:hover{ opacity:1; transform:translateY(-1px); }
    .fxHUD .dot{
      width:8px;height:8px;border-radius:99px;
      background:rgba(122,162,255,.95);
      box-shadow:0 0 0 2px rgba(122,162,255,.20);
    }
    .fxHUD.min .label{ display:none; }

    .controls{background:rgba(255,255,255,.03); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden;}
    .controlsHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap; padding:12px; border-bottom:1px solid var(--border);}
    .badge{font-size:12px;color:var(--muted); border:1px solid var(--border); padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.02);}
    .controlsBody{display:none;padding:12px;gap:12px}
    .controls.open .controlsBody{display:grid;}
    .grid{display:grid;grid-template-columns: 1fr 1fr; gap:12px;}
    @media (max-width: 980px){.grid{grid-template-columns: 1fr;}}
    .card{border:1px solid var(--border); border-radius:var(--radius); background:rgba(0,0,0,.22); overflow:hidden;}
    .cardBody{padding:12px;display:grid;gap:10px}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted);}
    input[type="text"], input[type="number"], select{
      width:100%; padding:10px; border-radius:12px;
      border:1px solid var(--border); background:rgba(0,0,0,.30);
      color:var(--text); font-size:14px; outline:none;
    }
    input[type="range"]{width:100%;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width: 740px){.row{grid-template-columns:1fr;}}
    .toggle{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:12px;user-select:none}
    .toggle input{transform:scale(1.05)}
    .miniBtns{display:flex;gap:8px;flex-wrap:wrap}
    .miniBtns button{padding:8px 10px;font-size:12px}
    .small{font-size:12px;color:var(--muted);line-height:1.25}

    /* collapsible menus */
    details.menu{
      border:1px solid var(--border);
      border-radius:16px;
      background:rgba(255,255,255,.02);
      overflow:hidden;
    }
    details.menu > summary{
      list-style:none;
      cursor:pointer;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
      font-weight:800;
      font-size:13px;
    }
    details.menu > summary::-webkit-details-marker{display:none}
    details.menu .inside{
      padding:12px;
      border-top:1px solid var(--border);
      display:grid;
      gap:10px;
    }
    details.menu .inside details.menu{
      background:rgba(0,0,0,.16);
    }

    /* range + number pair */
    .rpair{display:grid;grid-template-columns:1fr 110px;gap:10px;align-items:center}
    .rpair input[type="number"]{text-align:right}

    .layerList{display:grid;gap:10px}
    details.layerItem > summary{
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
      font-weight:800;
      font-size:13px;
      list-style:none;
      cursor:pointer;
    }
    details.layerItem > summary::-webkit-details-marker{display:none}
    details.layerItem{
      border:1px solid var(--border);
      border-radius:14px;
      background:rgba(255,255,255,.02);
      overflow:hidden;
    }
    details.layerItem .inside{
      padding:12px;
      border-top:1px solid var(--border);
      display:grid;
      gap:10px;
    }

    .deckList{display:grid;gap:12px}
    .deck{
      border:1px solid var(--border);
      border-radius:16px;
      background:rgba(255,255,255,.02);
      overflow:hidden;
    }
    .deckHead{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      font-weight:800;font-size:13px;
    }
    .thumbGrid{
      padding:12px;
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:10px;
    }
    @media (max-width:980px){.thumbGrid{grid-template-columns:repeat(2,1fr);}}
    .thumb{
      border:1px solid var(--border);
      border-radius:14px;
      overflow:hidden;
      background:#000;
      cursor:pointer;
      position:relative;
    }
    .thumb img{width:100%;height:auto;display:block;}
    .thumb .cap{
      position:absolute;left:0;right:0;bottom:0;
      padding:6px 8px;
      font-size:11px;
      background:linear-gradient(transparent, rgba(0,0,0,.75));
      color:rgba(255,255,255,.92);
      text-shadow:0 1px 2px rgba(0,0,0,.6);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">
      <h1>iVJ</h1>
    </div>

    <div class="actions">
      <div class="quickBar" id="quickBar">
        <span class="pill">Quick Random</span>
        <button class="quickBtn primary" id="qRand1">L1</button>
        <button class="quickBtn primary" id="qRand2">L2</button>
        <button class="quickBtn primary" id="qRand3">L3</button>
        <button class="quickBtn primary" id="qRand4">L4</button>
        <button class="quickBtn primary" id="qRand5">L5</button>
        <button class="quickBtn" id="qRandAll">All</button>
      </div>

      <button id="btnFullscreen" class="primary">Fullscreen Stage</button>
      <button id="btnToggleControls">Show Controls</button>
    </div>
  </div>

  <div class="stage" id="stage">
    <div id="mixStage">
      <div class="layersRoot" id="layersRoot"></div>
    </div>

    <!-- WebGL output overlay -->
    <canvas id="fxOut"></canvas>

    <!-- Minimal FX HUD on stage (only when capture exists) -->
    <div class="fxHUD min" id="fxHUD">
      <div class="btn" id="fxHUDToggle" title="Minimize / Expand">
        <span class="dot"></span><span class="label">FX</span>
      </div>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="controlsHead">
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <span class="badge" id="status">Status: idle</span>
        <span class="badge" id="deckStatus">Decks: not loaded</span>
      </div>
      <div class="miniBtns">
        <button id="addLayer">Add</button>
        <button id="removeLayer" class="danger">Remove</button>
        <button id="reloadLinks">Reload</button>
      </div>
    </div>

    <div class="controlsBody" id="controlsBody">
      <div class="grid">

        <!-- LEFT: Layers + FX -->
        <div class="card">
          <div class="cardBody">

            <details class="menu" open>
              <summary>Links</summary>
              <div class="inside">
                <div class="row">
                  <label>Tap UI
                    <select id="tapUI">
                      <option value="off" selected>off</option>
                      <option value="on">on</option>
                    </select>
                  </label>
                  <label>Loop
                    <select id="loopVideos">
                      <option value="on" selected>on</option>
                      <option value="off">off</option>
                    </select>
                  </label>
                  <label>Playback mode
                    <select id="playbackMode">
                      <option value="embed" selected>YouTube embed</option>
                      <option value="direct">Direct video (FX-friendly)</option>
                    </select>
                  </label>
                </div>
              </div>
            </details>

            <details class="menu" id="fxMenu">
              <summary>Capture FX</summary>
              <div class="inside">

                <div class="miniBtns">
                  <button id="capA" class="primary">Capture A</button>
                  <button id="capB" class="primary">Capture B</button>
                  <button id="capMix" class="primary">Capture Mix</button>
                  <button id="stopCap">Stop</button>
                </div>
                <div class="row">
                  <label>FX source
                    <select id="fxSource">
                      <option value="capture" selected>Capture (screen/tab)</option>
                      <option value="layers">Layers 1+2 (direct)</option>
                    </select>
                  </label>
                </div>
                <div class="small">Direct mode uses Layer 1+2 video (requires Direct playback).</div>

                <details class="menu" id="fxCaptureXform" open>
                  <summary>Capture Transform</summary>
                  <div class="inside">
                    <div class="row">
                      <label class="toggle"><input id="flipYA" type="checkbox" checked> A flip Y</label>
                      <label class="toggle"><input id="flipXA" type="checkbox"> A flip X</label>
                    </div>
                    <div class="row">
                      <label class="toggle"><input id="flipYB" type="checkbox" checked> B flip Y</label>
                      <label class="toggle"><input id="flipXB" type="checkbox"> B flip X</label>
                    </div>

                    <div class="row">
                      <label>Mirror mode
                        <select id="mirrorMode">
                          <option value="0" selected>off</option>
                          <option value="1">horiz</option>
                          <option value="2">vert</option>
                          <option value="3">both</option>
                        </select>
                      </label>
                      <label>Overlay blend
                        <select id="fxCanvasBlend">
                          <option value="normal" selected>normal</option>
                          <option value="screen">screen</option>
                          <option value="difference">difference</option>
                          <option value="overlay">overlay</option>
                          <option value="lighten">lighten</option>
                          <option value="multiply">multiply</option>
                        </select>
                      </label>
                    </div>

                    <label>Overlay opacity
                      <div class="rpair">
                        <input id="fxCanvasOpacity" type="range" min="0" max="1" step="0.01" value="1">
                        <input id="fxCanvasOpacity_n" type="number" min="0" max="1" step="0.01" value="1">
                      </div>
                    </label>

                  </div>
                </details>

                <details class="menu" open>
                  <summary>Mix</summary>
                  <div class="inside">
                    <div class="row">
                      <label>Blend (B over A)
                        <select id="fxBlend">
                          <option value="difference">difference</option>
                          <option value="screen">screen</option>
                          <option value="add">add</option>
                          <option value="multiply">multiply</option>
                          <option value="overlay">overlay</option>
                          <option value="exclusion">exclusion</option>
                          <option value="normal" selected>normal</option>
                        </select>
                      </label>

                      <label>B Opacity
                        <div class="rpair">
                          <input id="fxBOpacity" type="range" min="0" max="1" step="0.01" value="0.85">
                          <input id="fxBOpacity_n" type="number" min="0" max="1" step="0.01" value="0.85">
                        </div>
                      </label>
                    </div>

                    <div class="row">
                      <label>Invert B
                        <div class="rpair">
                          <input id="fxInvB" type="range" min="0" max="1" step="0.01" value="0">
                          <input id="fxInvB_n" type="number" min="0" max="1" step="0.01" value="0">
                        </div>
                      </label>

                      <label class="toggle" style="align-self:end">
                        <input id="useAasB" type="checkbox" checked> Use A as B
                      </label>
                    </div>

                    <div class="row">
                      <label>Exposure
                        <div class="rpair">
                          <input id="fxExposure" type="range" min="0.5" max="2.5" step="0.01" value="1.05">
                          <input id="fxExposure_n" type="number" min="0.5" max="2.5" step="0.01" value="1.05">
                        </div>
                      </label>
                      <label>Contrast
                        <div class="rpair">
                          <input id="fxContrast" type="range" min="0.5" max="3.0" step="0.01" value="1.35">
                          <input id="fxContrast_n" type="number" min="0.5" max="3.0" step="0.01" value="1.35">
                        </div>
                      </label>
                    </div>

                    <label>Saturation
                      <div class="rpair">
                        <input id="fxSat" type="range" min="0" max="3" step="0.01" value="1.25">
                        <input id="fxSat_n" type="number" min="0" max="3" step="0.01" value="1.25">
                      </div>
                    </label>
                  </div>
                </details>

                <details class="menu" open>
                  <summary>FX</summary>
                  <div class="inside">
                    <div class="miniBtns">
                      <button id="fxAllOff">All FX Off</button>
                    </div>

                    <div class="row">
                      <label class="toggle"><input id="tFeedback" type="checkbox"> Feedback</label>
                      <label>Affect
                        <select id="feedbackTarget">
                          <option value="final" selected>Final</option>
                          <option value="mix">Mix</option>
                          <option value="a">A</option>
                          <option value="b">B</option>
                        </select>
                      </label>
                    </div>
                    <div class="row">
                      <label>Amount
                        <div class="rpair">
                          <input id="feedbackAmt" type="range" min="0" max="0.98" step="0.001" value="0.88">
                          <input id="feedbackAmt_n" type="number" min="0" max="0.98" step="0.001" value="0.88">
                        </div>
                      </label>
                      <label>Zoom
                        <div class="rpair">
                          <input id="feedbackZoom" type="range" min="-0.08" max="0.12" step="0.001" value="0.06">
                          <input id="feedbackZoom_n" type="number" min="-0.08" max="0.12" step="0.001" value="0.06">
                        </div>
                      </label>
                    </div>
                    <label>Rotate
                      <div class="rpair">
                        <input id="feedbackRot" type="range" min="-2.5" max="2.5" step="0.01" value="0.12">
                        <input id="feedbackRot_n" type="number" min="-2.5" max="2.5" step="0.01" value="0.12">
                      </div>
                    </label>

                    <div class="row">
                      <label class="toggle"><input id="tKaleido" type="checkbox"> Kaleido</label>
                      <label>Affect
                        <select id="kaleidoTarget">
                          <option value="final" selected>Final</option>
                          <option value="mix">Mix</option>
                          <option value="a">A</option>
                          <option value="b">B</option>
                        </select>
                      </label>
                    </div>
                    <div class="row">
                      <label>Segments
                        <div class="rpair">
                          <input id="kSeg" type="range" min="2" max="16" step="1" value="6">
                          <input id="kSeg_n" type="number" min="2" max="16" step="1" value="6">
                        </div>
                      </label>
                      <label>Amount
                        <div class="rpair">
                          <input id="kAmt" type="range" min="0" max="1" step="0.01" value="0.85">
                          <input id="kAmt_n" type="number" min="0" max="1" step="0.01" value="0.85">
                        </div>
                      </label>
                    </div>
                    <label>Spin
                      <div class="rpair">
                        <input id="kSpin" type="range" min="-3" max="3" step="0.01" value="0">
                        <input id="kSpin_n" type="number" min="-3" max="3" step="0.01" value="0">
                      </div>
                    </label>

                    <div class="row">
                      <label class="toggle"><input id="tRGB" type="checkbox"> RGB Shift</label>
                      <label>Affect
                        <select id="rgbTarget">
                          <option value="b">B</option>
                          <option value="a">A</option>
                          <option value="mix">Mix</option>
                          <option value="final" selected>Final</option>
                        </select>
                      </label>
                    </div>
                    <label>Amount
                      <div class="rpair">
                        <input id="rgbAmt" type="range" min="0" max="0.05" step="0.0005" value="0.012">
                        <input id="rgbAmt_n" type="number" min="0" max="0.05" step="0.0005" value="0.012">
                      </div>
                    </label>

                    <div class="row">
                      <label class="toggle"><input id="tGlitch" type="checkbox"> Glitch</label>
                      <label>Affect
                        <select id="glitchTarget">
                          <option value="mix">Mix</option>
                          <option value="final" selected>Final</option>
                          <option value="a">A</option>
                          <option value="b">B</option>
                        </select>
                      </label>
                    </div>
                    <label>Amount
                      <div class="rpair">
                        <input id="glitchAmt" type="range" min="0" max="1" step="0.01" value="0.35">
                        <input id="glitchAmt_n" type="number" min="0" max="1" step="0.01" value="0.35">
                      </div>
                    </label>

                    <div class="row">
                      <label class="toggle"><input id="tPixel" type="checkbox"> Pixelate</label>
                      <label>Affect
                        <select id="pixelTarget">
                          <option value="final" selected>Final</option>
                          <option value="mix">Mix</option>
                          <option value="a">A</option>
                          <option value="b">B</option>
                        </select>
                      </label>
                    </div>
                    <label>Size
                      <div class="rpair">
                        <input id="pixSize" type="range" min="1" max="220" step="1" value="70">
                        <input id="pixSize_n" type="number" min="1" max="220" step="1" value="70">
                      </div>
                    </label>

                    <div class="row">
                      <label class="toggle"><input id="tScan" type="checkbox"> Scanlines</label>
                      <label class="toggle"><input id="tVig" type="checkbox"> Vignette</label>
                    </div>
                    <div class="row">
                      <label>Scan amount
                        <div class="rpair">
                          <input id="scanAmt" type="range" min="0" max="1" step="0.01" value="0.35">
                          <input id="scanAmt_n" type="number" min="0" max="1" step="0.01" value="0.35">
                        </div>
                      </label>
                      <label>Vignette amount
                        <div class="rpair">
                          <input id="vigAmt" type="range" min="0" max="1" step="0.01" value="0.55">
                          <input id="vigAmt_n" type="number" min="0" max="1" step="0.01" value="0.55">
                        </div>
                      </label>
                    </div>

                  </div>
                </details>

              </div>
            </details>

            <details class="menu" open>
              <summary>Layers</summary>
              <div class="inside">
                <div class="layerList" id="layerList"></div>
              </div>
            </details>

          </div>
        </div>

        <!-- RIGHT: Decks -->
        <div class="card">
          <div class="cardBody">

            <details class="menu" open>
              <summary>Decks</summary>
              <div class="inside">

                <div class="row">
                  <label>Send click to layer
                    <select id="deckTargetLayer"></select>
                  </label>
                  <label>Invidious base
                    <input id="invBaseCustom" type="text" placeholder="optional (default inv.nadeko.net)"/>
                  </label>
                </div>

                <div class="row">
                  <label>Add playlist URL
                    <input id="customPlaylistUrl" type="text" placeholder="...&list=PLxxxx"/>
                  </label>
                  <div style="display:flex;gap:8px;align-items:end;flex-wrap:wrap">
                    <button id="addCustomDeck" class="primary">Add Deck</button>
                    <button id="reloadAllDecks">Reload</button>
                  </div>
                </div>

                <div class="row">
                  <label>Thumbs per deck
                    <select id="thumbCount">
                      <option value="24">24</option>
                      <option value="48" selected>48</option>
                      <option value="96">96</option>
                      <option value="200">200</option>
                      <option value="999999">All</option>
                    </select>
                  </label>
                  <label class="toggle" style="align-self:end">
                    <input id="thumbShuffle" type="checkbox" checked>
                    Shuffle
                  </label>
                </div>

                <div class="row">
                  <label>Random → All source
                    <select id="randomAllDeck"></select>
                  </label>
                  <div style="display:flex;gap:8px;align-items:end;flex-wrap:wrap">
                    <button id="randomAllLayers" class="primary">Random → All</button>
                  </div>
                </div>

                <div class="deckList" id="deckList"></div>

              </div>
            </details>

          </div>
        </div>

      </div>
    </div>
  </div>
</div>

<script>
const $ = (id)=>document.getElementById(id);

/* =========================
   Controls open/close + fullscreen
========================= */
const controls = $("controls");
$("btnToggleControls").addEventListener("click", ()=>{
  controls.classList.toggle("open");
  $("btnToggleControls").textContent = controls.classList.contains("open") ? "Hide Controls" : "Show Controls";
});
controls.classList.remove("open");
$("btnToggleControls").textContent = "Show Controls";

const stageEl = $("stage");
function isFullscreen(){ return document.fullscreenElement === stageEl; }
async function toggleFullscreen(){
  try{
    if (!isFullscreen()) await stageEl.requestFullscreen({navigationUI:"hide"});
    else await document.exitFullscreen();
  }catch(e){}
}
$("btnFullscreen").addEventListener("click", toggleFullscreen);
document.addEventListener("fullscreenchange", ()=>{
  $("btnFullscreen").textContent = isFullscreen() ? "Exit Fullscreen" : "Fullscreen Stage";
  resizeCanvas();
});

/* =========================
   Link Mixer
========================= */
const DEFAULT_LINKS = [
  "https://www.youtube.com/watch?v=3pxrECZYEAA",
  "https://www.youtube.com/watch?v=dS-MaUk6YBI"
];
const BLENDS = [
  "normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn",
  "hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"
];

let linkLayerCount = 2;
const linkLayers = []; // {el, iframe, video, url, ui, auto}
let layerAutoTimers = new Map();

function fillBlendOptions(sel, def="difference"){
  sel.innerHTML = BLENDS.map(b=>`<option value="${b}">${b}</option>`).join("");
  sel.value = def;
}

function extractVideoId(url){
  if (!url) return null;
  const raw = url.trim();
  if (/^[a-zA-Z0-9_-]{11}$/.test(raw)) return raw;
  try{
    const u = new URL(raw);
    if (u.hostname.includes("youtu.be")) return u.pathname.replace("/","") || null;
    const v = u.searchParams.get("v");
    if (v) return v;
  }catch(e){}
  return null;
}

function buildEmbedSrc(videoId){
  const origin = encodeURIComponent(location.origin);
  const loopOn = $("loopVideos").value === "on";
  const loopPart = loopOn ? `&loop=1&playlist=${videoId}` : "";
  return `https://www.youtube.com/embed/${videoId}?playsinline=1&autoplay=1&mute=1&controls=0&rel=0&modestbranding=1&iv_load_policy=3&fs=0&disablekb=1&enablejsapi=1&origin=${origin}${loopPart}`;
}

function buildDirectSrc(videoId){
  const base = getInvidiousBase();
  return `${base}/latest_version?id=${encodeURIComponent(videoId)}&itag=18&local=true`;
}

function makeLinkLayer(i){
  const el = document.createElement("div");
  el.className = "layer";
  el.style.zIndex = String(10 + i);
  $("layersRoot").appendChild(el);
  return el;
}

function mountLinkIframe(i){
  const L = linkLayers[i];
  const vid = extractVideoId(L.url);
  if (!vid){ L.el.innerHTML=""; L.iframe=null; L.video=null; return; }
  if ($("playbackMode").value === "direct"){
    const src = buildDirectSrc(vid);
    const loopOn = $("loopVideos").value === "on";
    L.el.innerHTML = `<video data-layer="${i}" playsinline muted autoplay ${loopOn ? "loop" : ""} crossorigin="anonymous"></video>`;
    L.video = L.el.querySelector("video");
    L.video.src = src;
    L.video.play().catch(()=>{});
    L.iframe = null;
  }else{
    const src = buildEmbedSrc(vid);
    L.el.innerHTML = `<iframe data-layer="${i}" allow="autoplay; encrypted-media; picture-in-picture" src="${src}"></iframe>`;
    L.iframe = L.el.querySelector("iframe");
    L.video = null;
  }
}

function applyLinkStyle(i){
  const L = linkLayers[i];
  if (!L) return;
  const tap = $("tapUI").value === "on";
  L.el.style.pointerEvents = tap ? "auto" : "none";
  L.el.style.opacity = L.ui.op;
  L.el.style.mixBlendMode = L.ui.blend;

  const z = Math.max(1, L.ui.zoom || 1);
  const cx = (L.ui.cx ?? 0.5);
  const cy = (L.ui.cy ?? 0.5);
  const tx = (0.5 - cx) * 100;
  const ty = (0.5 - cy) * 100;
  L.el.style.transformOrigin = `${cx*100}% ${cy*100}%`;
  L.el.style.transform = `translate(${tx}%, ${ty}%) scale(${z})`;

  L.el.style.filter = `invert(${L.ui.inv}) contrast(${L.ui.ct}) saturate(${L.ui.sat}) hue-rotate(${L.ui.hue}deg)`;
}

/* YouTube JS API postMessage controls */
function ytCommand(i, cmd){
  const L = linkLayers[i];
  const ifr = L?.iframe;
  if (!ifr || !ifr.contentWindow) return;
  try{
    ifr.contentWindow.postMessage(
      JSON.stringify({ event:"command", func: cmd, args: [] }),
      "https://www.youtube.com"
    );
  }catch(e){}
}
function playLayer(i){
  const L = linkLayers[i];
  if (L?.video){ L.video.play().catch(()=>{}); }
  else { ytCommand(i,"playVideo"); }
  $("status").textContent=`Status: play L${i+1}`;
}
function pauseLayer(i){
  const L = linkLayers[i];
  if (L?.video){ L.video.pause(); }
  else { ytCommand(i,"pauseVideo"); }
  $("status").textContent=`Status: pause L${i+1}`;
}

function stopAllLayerAuto(){
  for (const [i, timer] of layerAutoTimers.entries()) clearInterval(timer);
  layerAutoTimers.clear();
}
function syncLayerAuto(i){
  const L = linkLayers[i];
  if (!L) return;
  if (layerAutoTimers.has(i)){
    clearInterval(layerAutoTimers.get(i));
    layerAutoTimers.delete(i);
  }
  if (!L.auto.on) return;
  const ms = Math.max(5000, L.auto.ms || 30000);
  const timer = setInterval(()=>pickRandomIntoLayer(i), ms);
  layerAutoTimers.set(i, timer);
}

function updateDeckTargetLayerOptions(){
  const sel = $("deckTargetLayer");
  sel.innerHTML = "";
  for (let i=0;i<linkLayerCount;i++){
    const o = document.createElement("option");
    o.value = String(i);
    o.textContent = `Layer ${i+1}`;
    sel.appendChild(o);
  }
}

/* =========================
   Decks (Invidious playlists)
========================= */
const DEFAULT_DECKS = [
  { key:"trippy", name:"Trippy", url:"https://www.youtube.com/watch?v=sLkwdr74FVI&list=PLuyTQuSXZ5EUeHHskJJmWqicuyKJK4kc2" },
  { key:"cartoons", name:"Cartoons", url:"https://www.youtube.com/watch?v=2lBjRpRtQjY&list=PL1ZB2TfCq41TxhYoCOeYiwONkig6Lt_C3" },
  { key:"commercials", name:"Commercials", url:"https://www.youtube.com/watch?v=0tJ_KhgI4TY&list=PLxqMsrhM_WC25QOMHMQp-Cm9k6nfc_vPu" }
];

const decks = {}; // key -> {name,url,listId,items:[{videoId,title,thumb}]}
let DEFAULT_DECK_KEY = "trippy";

function getInvidiousBase(){
  const custom = ($("invBaseCustom").value || "").trim().replace(/\/+$/,'');
  if (custom) return custom;
  return "https://inv.nadeko.net";
}
function extractPlaylistId(anyUrl){
  if (!anyUrl) return null;
  const raw = anyUrl.trim();
  try{
    const u = new URL(raw);
    const list = u.searchParams.get("list");
    if (list) return list;
    if (u.pathname.includes("/playlist")) return u.searchParams.get("list");
  }catch(e){}
  if (/^PL[a-zA-Z0-9_-]{10,}$/.test(raw)) return raw;
  return null;
}
function deckThumbUrl(videoId){
  return `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;
}
async function fetchPlaylistAllVideos(listId){
  const base = getInvidiousBase();
  const out = [];
  for (let page=1; page<=25; page++){
    const url = `${base}/api/v1/playlists/${encodeURIComponent(listId)}?page=${page}`;
    const r = await fetch(url, { mode:"cors" });
    if (!r.ok) break;
    const j = await r.json();
    const vids = Array.isArray(j.videos) ? j.videos : [];
    if (!vids.length) break;
    for (const v of vids){
      const vid = v.videoId || v.video_id || v.id;
      if (!vid) continue;
      out.push({ videoId: vid, title: v.title || "" });
    }
  }
  const seen = new Set();
  return out.filter(x=> (seen.has(x.videoId) ? false : (seen.add(x.videoId), true)));
}
function addDeck(key, name, url){
  const listId = extractPlaylistId(url);
  if (!listId){
    $("deckStatus").textContent = "Decks: invalid playlist";
    return false;
  }
  decks[key] = { key, name, url, listId, items: [] };
  return true;
}
function initDefaultDecks(){ DEFAULT_DECKS.forEach(d=>addDeck(d.key, d.name, d.url)); }
async function loadDeck(key){
  const D = decks[key];
  if (!D || !D.listId) return;
  $("deckStatus").textContent = `Decks: loading ${D.name}…`;
  try{
    const items = await fetchPlaylistAllVideos(D.listId);
    D.items = items.map(it=>({
      videoId: it.videoId,
      title: it.title || it.videoId,
      thumb: deckThumbUrl(it.videoId)
    }));
    $("deckStatus").textContent = `Decks: loaded ${D.name} (${D.items.length})`;
  }catch(e){
    console.error(e);
    $("deckStatus").textContent = `Decks: failed ${D.name}`;
    D.items = [];
  }
}
function shuffledCopy(arr){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function refreshDeckDropdowns(){
  const randSel = $("randomAllDeck");
  const cur = randSel.value || DEFAULT_DECK_KEY;
  randSel.innerHTML = Object.keys(decks).map(k=>`<option value="${k}">${decks[k].name}</option>`).join("");
  randSel.value = decks[cur] ? cur : DEFAULT_DECK_KEY;

  document.querySelectorAll(`select[data-f="autoDeck"]`).forEach(sel=>{
    const i = parseInt(sel.getAttribute("data-i"),10);
    const L = linkLayers[i];
    const cur2 = L?.auto?.deckKey || DEFAULT_DECK_KEY;
    sel.innerHTML = Object.keys(decks).map(k=>`<option value="${k}">${decks[k].name}</option>`).join("");
    sel.value = decks[cur2] ? cur2 : DEFAULT_DECK_KEY;
  });
}
function renderDecks(){
  const wrap = $("deckList");
  wrap.innerHTML = "";

  const limit = parseInt($("thumbCount").value,10) || 48;
  const doShuffle = $("thumbShuffle").checked;

  Object.keys(decks).forEach(key=>{
    const D = decks[key];
    const el = document.createElement("div");
    el.className = "deck";
    el.innerHTML = `
      <div class="deckHead">
        <div>${D.name}</div>
        <div class="miniBtns">
          <button data-act="reloadDeck" data-k="${key}">Load</button>
          <button data-act="setDefault" data-k="${key}">Set Default</button>
        </div>
      </div>
      <div class="thumbGrid" id="thumbGrid_${key}">
        <div class="small" style="grid-column:1/-1;">${D.items?.length ? "" : "Not loaded"}</div>
      </div>
    `;
    wrap.appendChild(el);

    const grid = el.querySelector(`#thumbGrid_${key}`);
    if (Array.isArray(D.items) && D.items.length){
      grid.innerHTML = "";
      const itemsForDisplay = doShuffle ? shuffledCopy(D.items) : D.items;
      const show = (limit >= 999999) ? itemsForDisplay : itemsForDisplay.slice(0, limit);

      for (const it of show){
        const t = document.createElement("div");
        t.className = "thumb";
        t.innerHTML = `
          <img loading="lazy" referrerpolicy="no-referrer"
               src="${it.thumb}" alt="">
          <div class="cap">${it.title || it.videoId}</div>
        `;
        t.addEventListener("click", ()=>pushVideoToLayer(it.videoId, null));
        grid.appendChild(t);
      }
    }
  });

  refreshDeckDropdowns();
}

$("deckList").addEventListener("click", async (e)=>{
  const b = e.target.closest("button[data-act]");
  if (!b) return;
  const act = b.getAttribute("data-act");
  const k = b.getAttribute("data-k");
  if (act==="reloadDeck"){
    await loadDeck(k);
    renderDecks();
  }
  if (act==="setDefault"){
    DEFAULT_DECK_KEY = k;
    $("deckStatus").textContent = `Decks: default = ${decks[k].name}`;
    refreshDeckDropdowns();
  }
});

$("addCustomDeck").addEventListener("click", async ()=>{
  const url = $("customPlaylistUrl").value.trim();
  if (!url) return;
  const listId = extractPlaylistId(url);
  if (!listId){
    $("deckStatus").textContent = "Decks: invalid playlist";
    return;
  }
  const key = "custom_" + Math.random().toString(16).slice(2,8);
  addDeck(key, "Custom", url);
  await loadDeck(key);
  renderDecks();
  $("customPlaylistUrl").value = "";
});

$("reloadAllDecks").addEventListener("click", async ()=>{
  $("deckStatus").textContent = "Decks: loading…";
  for (const k of Object.keys(decks)) await loadDeck(k);
  renderDecks();
  $("deckStatus").textContent = "Decks: loaded";
});

$("thumbCount").addEventListener("change", renderDecks);
$("thumbShuffle").addEventListener("change", renderDecks);

function pickRandomFromDeck(key){
  const D = decks[key];
  if (!D || !Array.isArray(D.items) || !D.items.length) return null;
  const idx = Math.floor(Math.random() * D.items.length);
  return D.items[idx].videoId;
}
function pushVideoToLayer(videoId, layerIndex=null){
  const i = (layerIndex === null)
    ? (parseInt($("deckTargetLayer").value, 10) || 0)
    : layerIndex;

  const url = `https://www.youtube.com/watch?v=${videoId}`;
  linkLayers[i].url = url;

  const inp = document.querySelector(`input[data-f="url"][data-i="${i}"]`);
  if (inp) inp.value = url;

  mountLinkIframe(i);
  applyLinkStyle(i);
  $("status").textContent = `Status: set L${i+1}`;
}
function pickRandomIntoLayer(i){
  const L = linkLayers[i];
  const deckKey = L.auto.deckKey || DEFAULT_DECK_KEY;
  const vid = pickRandomFromDeck(deckKey);
  if (!vid){
    $("status").textContent = `Status: deck not loaded`;
    return;
  }
  pushVideoToLayer(vid, i);
}
function randomizeAllLayers(){
  const deckKey = $("randomAllDeck").value || DEFAULT_DECK_KEY;
  const D = decks[deckKey];
  if (!D || !Array.isArray(D.items) || !D.items.length){
    $("status").textContent = `Status: deck not loaded`;
    return;
  }
  const vids = D.items.map(x=>x.videoId);
  const shuffled = vids.slice().sort(()=>Math.random()-0.5);
  for (let i=0;i<linkLayerCount;i++){
    const vid = shuffled[i] || vids[Math.floor(Math.random()*vids.length)];
    pushVideoToLayer(vid, i);
  }
  $("status").textContent = `Status: random → all`;
}
$("randomAllLayers").addEventListener("click", randomizeAllLayers);

/* Quick random buttons */
function updateQuickButtons(){
  for (let i=1;i<=5;i++){
    const b = $("qRand"+i);
    if (!b) continue;
    b.style.display = (linkLayerCount >= i) ? "inline-flex" : "none";
  }
}
$("qRand1").addEventListener("click", ()=>pickRandomIntoLayer(0));
$("qRand2").addEventListener("click", ()=>pickRandomIntoLayer(1));
$("qRand3").addEventListener("click", ()=>pickRandomIntoLayer(2));
$("qRand4").addEventListener("click", ()=>pickRandomIntoLayer(3));
$("qRand5").addEventListener("click", ()=>pickRandomIntoLayer(4));
$("qRandAll").addEventListener("click", ()=>randomizeAllLayers());

/* Build Layer UI */
function rebuildLinkUI(){
  const list = $("layerList");
  list.innerHTML = "";

  for (let i=0;i<linkLayerCount;i++){
    const item = document.createElement("details");
    item.className="layerItem";
    item.open = false;
    item.innerHTML = `
      <summary>
        <span>Layer ${i+1}</span>
        <span class="miniBtns">
          <button type="button" data-act="play" data-i="${i}">Play</button>
          <button type="button" data-act="pause" data-i="${i}">Pause</button>
          <button type="button" data-act="pickRandom" data-i="${i}" class="primary">Random</button>
          <button type="button" data-act="apply" data-i="${i}">Apply</button>
        </span>
      </summary>
      <div class="inside">
        <label>YouTube URL or ID <input type="text" data-f="url" data-i="${i}"/></label>

        <div class="row">
          <label>Opacity
            <div class="rpair">
              <input type="range" min="0" max="1" step="0.01" data-f="op" data-i="${i}"/>
              <input type="number" min="0" max="1" step="0.01" data-f="op_n" data-i="${i}"/>
            </div>
          </label>
          <label>Blend <select data-f="blend" data-i="${i}"></select></label>
        </div>

        <div class="row">
          <label>Invert
            <div class="rpair">
              <input type="range" min="0" max="1" step="0.01" data-f="inv" data-i="${i}"/>
              <input type="number" min="0" max="1" step="0.01" data-f="inv_n" data-i="${i}"/>
            </div>
          </label>
          <label>Contrast
            <div class="rpair">
              <input type="range" min="0.5" max="3" step="0.01" data-f="ct" data-i="${i}"/>
              <input type="number" min="0.5" max="3" step="0.01" data-f="ct_n" data-i="${i}"/>
            </div>
          </label>
        </div>

        <div class="row">
          <label>Saturation
            <div class="rpair">
              <input type="range" min="0" max="3" step="0.01" data-f="sat" data-i="${i}"/>
              <input type="number" min="0" max="3" step="0.01" data-f="sat_n" data-i="${i}"/>
            </div>
          </label>
          <label>Hue
            <div class="rpair">
              <input type="range" min="-180" max="180" step="1" data-f="hue" data-i="${i}"/>
              <input type="number" min="-180" max="180" step="1" data-f="hue_n" data-i="${i}"/>
            </div>
          </label>
        </div>

        <details class="menu">
          <summary>Crop / Zoom</summary>
          <div class="inside">
            <div class="row">
              <label>Center X
                <div class="rpair">
                  <input type="range" min="0" max="1" step="0.001" data-f="cx" data-i="${i}"/>
                  <input type="number" min="0" max="1" step="0.001" data-f="cx_n" data-i="${i}"/>
                </div>
              </label>
              <label>Center Y
                <div class="rpair">
                  <input type="range" min="0" max="1" step="0.001" data-f="cy" data-i="${i}"/>
                  <input type="number" min="0" max="1" step="0.001" data-f="cy_n" data-i="${i}"/>
                </div>
              </label>
            </div>
            <label>Zoom
              <div class="rpair">
                <input type="range" min="1" max="5" step="0.01" data-f="zoom" data-i="${i}"/>
                <input type="number" min="1" max="5" step="0.01" data-f="zoom_n" data-i="${i}"/>
              </div>
            </label>
          </div>
        </details>

        <details class="menu">
          <summary>Auto Random</summary>
          <div class="inside">
            <div class="row">
              <label class="toggle"><input type="checkbox" data-f="autoOn" data-i="${i}"> Enable</label>
              <label>Deck
                <select data-f="autoDeck" data-i="${i}"></select>
              </label>
            </div>
            <label>Timer (sec)
              <div class="rpair">
                <input type="range" min="5" max="600" step="1" data-f="autoSec" data-i="${i}"/>
                <input type="number" min="5" max="600" step="1" data-f="autoSec_n" data-i="${i}"/>
              </div>
            </label>
          </div>
        </details>

        <details class="menu">
          <summary>Capture (sets A/B)</summary>
          <div class="inside">
            <div class="miniBtns">
              <button type="button" data-act="capA" data-i="${i}" class="primary">Capture A</button>
              <button type="button" data-act="capB" data-i="${i}" class="primary">Capture B</button>
              <button type="button" data-act="capMix" data-i="${i}" class="primary">Capture Mix</button>
              <button type="button" data-act="stopCap" data-i="${i}">Stop</button>
            </div>
            <div class="small">Pick “This Tab” for Capture Mix, or a window for A/B.</div>
          </div>
        </details>

      </div>
    `;
    list.appendChild(item);

    const L = linkLayers[i];
    item.querySelector(`[data-f="url"][data-i="${i}"]`).value = L.url;

    const setPair = (f, v)=>{
      const r = item.querySelector(`input[data-f="${f}"][data-i="${i}"]`);
      const n = item.querySelector(`input[data-f="${f}_n"][data-i="${i}"]`);
      if (r) r.value = v;
      if (n) n.value = v;
    };

    setPair("op", L.ui.op);
    setPair("inv", L.ui.inv);
    setPair("ct", L.ui.ct);
    setPair("sat", L.ui.sat);
    setPair("hue", L.ui.hue);

    setPair("cx", L.ui.cx ?? 0.5);
    setPair("cy", L.ui.cy ?? 0.5);
    setPair("zoom", L.ui.zoom ?? 1);

    const sel = item.querySelector(`select[data-f="blend"][data-i="${i}"]`);
    fillBlendOptions(sel, L.ui.blend);

    item.querySelector(`[data-f="autoOn"][data-i="${i}"]`).checked = !!L.auto.on;
    const sec = Math.round((L.auto.ms||30000)/1000);
    setPair("autoSec", sec);

    const deckSel = item.querySelector(`select[data-f="autoDeck"][data-i="${i}"]`);
    deckSel.innerHTML = Object.keys(decks).map(k=>`<option value="${k}">${decks[k].name}</option>`).join("");
    deckSel.value = L.auto.deckKey || DEFAULT_DECK_KEY;
  }

  updateDeckTargetLayerOptions();
  refreshDeckDropdowns();
  updateQuickButtons();
}

function rebuildLinkLayers(){
  $("layersRoot").innerHTML="";
  linkLayers.length=0;
  stopAllLayerAuto();

  for (let i=0;i<linkLayerCount;i++){
    const el = makeLinkLayer(i);
    linkLayers.push({
      el,
      iframe: null,
      url: DEFAULT_LINKS[i] || DEFAULT_LINKS[1],
      ui: {
        op:i===0?1:0.85,
        blend:i===0?"normal":"difference",
        inv:i===0?0:1,
        ct:i===0?1:1.6,
        sat:i===0?1:1.2,
        hue:0,
        cx:0.5, cy:0.5, zoom:1
      },
      auto: { on:false, ms:30000, deckKey: DEFAULT_DECK_KEY }
    });
    mountLinkIframe(i);
    applyLinkStyle(i);
  }

  rebuildLinkUI();
}

$("addLayer").addEventListener("click", ()=>{ if (linkLayerCount<5){ linkLayerCount++; rebuildLinkLayers(); renderDecks(); }});
$("removeLayer").addEventListener("click", ()=>{ if (linkLayerCount>2){ linkLayerCount--; rebuildLinkLayers(); renderDecks(); }});
$("reloadLinks").addEventListener("click", ()=>{ for (let i=0;i<linkLayerCount;i++){ mountLinkIframe(i); applyLinkStyle(i);} });
$("tapUI").addEventListener("change", ()=>{ for (let i=0;i<linkLayerCount;i++) applyLinkStyle(i); });
$("loopVideos").addEventListener("change", ()=>{ for (let i=0;i<linkLayerCount;i++) mountLinkIframe(i); });
$("playbackMode").addEventListener("change", ()=>{
  for (let i=0;i<linkLayerCount;i++){
    mountLinkIframe(i);
    applyLinkStyle(i);
  }
  updateFxOverlayActive();
});

/* Layer input sync (range<->number + values) */
function syncPair(rangeEl, numEl){
  if (!rangeEl || !numEl) return;
  const clamp = (v)=>{
    let x = Number(v);
    if (Number.isNaN(x)) x = Number(rangeEl.value);
    const mn = (rangeEl.min!==""?Number(rangeEl.min):-Infinity);
    const mx = (rangeEl.max!==""?Number(rangeEl.max):Infinity);
    x = Math.min(mx, Math.max(mn, x));
    return x;
  };
  rangeEl.addEventListener("input", ()=>{
    numEl.value = rangeEl.value;
    rangeEl.dispatchEvent(new Event("rangePairChanged", {bubbles:true}));
  });
  numEl.addEventListener("change", ()=>{
    const v = clamp(numEl.value);
    rangeEl.value = v;
    numEl.value = v;
    rangeEl.dispatchEvent(new Event("rangePairChanged", {bubbles:true}));
  });
}

function initAllPairs(){
  // global pairs with _n suffix
  document.querySelectorAll('input[type="range"][id]').forEach(r=>{
    const n = $(r.id + "_n");
    if (n) syncPair(r,n);
  });
}

$("layerList").addEventListener("rangePairChanged", (e)=>{
  const t = e.target; // range
  const i = parseInt(t.getAttribute("data-i"),10);
  const f = t.getAttribute("data-f");
  if (Number.isNaN(i)||!f) return;
  const L=linkLayers[i]; if (!L) return;

  const v = t.value;

  if (f==="op") L.ui.op=parseFloat(v);
  if (f==="inv") L.ui.inv=parseFloat(v);
  if (f==="ct") L.ui.ct=parseFloat(v);
  if (f==="sat") L.ui.sat=parseFloat(v);
  if (f==="hue") L.ui.hue=parseInt(v,10);

  if (f==="cx") L.ui.cx=parseFloat(v);
  if (f==="cy") L.ui.cy=parseFloat(v);
  if (f==="zoom") L.ui.zoom=parseFloat(v);

  if (f==="autoSec") { L.auto.ms = Math.max(5000, parseInt(v,10)*1000); syncLayerAuto(i); }

  applyLinkStyle(i);
});

$("layerList").addEventListener("input", (e)=>{
  const t=e.target;
  const i=parseInt(t.getAttribute("data-i"),10);
  const f=t.getAttribute("data-f");
  if (Number.isNaN(i)||!f) return;
  const L=linkLayers[i]; if (!L) return;

  if (f==="url") L.url=t.value;

  if (f==="autoOn") { L.auto.on = t.checked; syncLayerAuto(i); }
  if (f==="autoDeck") { L.auto.deckKey = t.value; syncLayerAuto(i); }

  if (f==="blend") { L.ui.blend=t.value; applyLinkStyle(i); }

  // keep paired number/range mirrored for non-range inputs
  if (f.endsWith("_n")){
    const base = f.replace(/_n$/,'');
    const r = document.querySelector(`input[type="range"][data-f="${base}"][data-i="${i}"]`);
    if (r){ r.value = t.value; r.dispatchEvent(new Event("rangePairChanged", {bubbles:true})); }
  }
});

$("layerList").addEventListener("click", (e)=>{
  const btn=e.target.closest("button[data-act]");
  if (!btn) return;
  const i=parseInt(btn.getAttribute("data-i"),10);
  const act = btn.getAttribute("data-act");
  if (act==="apply"){ mountLinkIframe(i); applyLinkStyle(i); }
  if (act==="pickRandom"){ pickRandomIntoLayer(i); }
  if (act==="play"){ playLayer(i); }
  if (act==="pause"){ pauseLayer(i); }

  // capture controls inside layer submenu
  if (act==="capA"){ startCapture("A"); }
  if (act==="capB"){ startCapture("B"); }
  if (act==="capMix"){ startCapture("Mix"); }
  if (act==="stopCap"){ stopCaptureAll(); }
});

/* =========================
   Capture (A/B) + FX overlay enable/disable
========================= */
let capStreamA=null, capStreamB=null;
const capVideoA=document.createElement("video");
const capVideoB=document.createElement("video");
capVideoA.muted=true; capVideoB.muted=true;
capVideoA.playsInline=true; capVideoB.playsInline=true;

function stopStream(stream){
  if (!stream) return;
  for (const tr of stream.getTracks()) tr.stop();
}

function getLayerVideo(i){
  return linkLayers[i]?.video || null;
}

function getFxSourceState(){
  const mode = $("fxSource").value;
  if (mode === "layers"){
    const videoA = getLayerVideo(0);
    const videoB = getLayerVideo(1);
    const hasA = !!videoA && videoA.readyState >= 2;
    const hasB = !!videoB && videoB.readyState >= 2;
    return { active: hasA || hasB, videoA, videoB, hasA, hasB };
  }
  const hasA = !!capStreamA && capVideoA.readyState >= 2;
  const hasB = !!capStreamB && capVideoB.readyState >= 2;
  return { active: !!capStreamA || !!capStreamB, videoA: capVideoA, videoB: capVideoB, hasA, hasB };
}

function updateFxOverlayActive(){
  const { active } = getFxSourceState();
  setFxOverlayActive(active);
}

function setFxOverlayActive(active){
  $("fxOut").style.display = active ? "block" : "none";
  $("fxHUD").style.display = active ? "block" : "none";

  if (active){
    $("fxOut").style.mixBlendMode = $("fxCanvasBlend").value;
    $("fxOut").style.opacity = String($("fxCanvasOpacity").value);
  }
}

async function startCapture(which){
  try{
    const stream = await navigator.mediaDevices.getDisplayMedia({ video:{ frameRate:60 }, audio:false });
    if (which==="A"){
      stopStream(capStreamA);
      capStreamA=stream; capVideoA.srcObject=stream; await capVideoA.play();
      // default fix for upside-down
      $("flipYA").checked = true;
    }else if (which==="B"){
      stopStream(capStreamB);
      capStreamB=stream; capVideoB.srcObject=stream; await capVideoB.play();
      // default fix for upside-down
      $("flipYB").checked = true;
    }else{
      stopStream(capStreamA);
      stopStream(capStreamB);
      capStreamA=stream; capVideoA.srcObject=stream; await capVideoA.play();
      capStreamB=null; capVideoB.srcObject=null;
      $("useAasB").checked = true;
    }
    $("status").textContent = `Status: captured ${which}`;
    updateFxOverlayActive();
  }catch(e){
    $("status").textContent = `Status: capture ${which} canceled/blocked`;
  }
}

function stopCaptureAll(){
  stopStream(capStreamA);
  stopStream(capStreamB);
  capStreamA=null; capStreamB=null;
  capVideoA.srcObject=null; capVideoB.srcObject=null;

  updateFxOverlayActive();
  $("status").textContent="Status: capture stopped";
}
$("capA").addEventListener("click", ()=>startCapture("A"));
$("capB").addEventListener("click", ()=>startCapture("B"));
$("capMix").addEventListener("click", ()=>startCapture("Mix"));
$("stopCap").addEventListener("click", stopCaptureAll);
$("fxSource").addEventListener("change", ()=>{
  updateFxOverlayActive();
  if ($("fxSource").value === "layers" && $("playbackMode").value !== "direct"){
    $("status").textContent = "Status: Direct playback required for Layer FX source";
  }
});

$("fxAllOff").addEventListener("click", ()=>{
  $("tFeedback").checked=false; $("tKaleido").checked=false; $("tRGB").checked=false;
  $("tGlitch").checked=false; $("tPixel").checked=false; $("tScan").checked=false; $("tVig").checked=false;
});

/* FX HUD behavior */
$("fxHUDToggle").addEventListener("click", ()=>{
  $("fxHUD").classList.toggle("min");
  // open FX menu if expanding
  if (!$("fxHUD").classList.contains("min")){
    controls.classList.add("open");
    $("btnToggleControls").textContent = "Hide Controls";
    $("fxMenu").open = true;
    $("fxMenu").scrollIntoView({behavior:"smooth", block:"start"});
  }
});

$("fxCanvasBlend").addEventListener("change", ()=>{
  $("fxOut").style.mixBlendMode = $("fxCanvasBlend").value;
});
function bindSimplePair(rangeId, numId){
  const r = $(rangeId);
  const n = $(numId);
  if (!r || !n) return;
  syncPair(r,n);
  r.addEventListener("input", ()=>{
    $("fxOut").style.opacity = String($("fxCanvasOpacity").value);
  });
  n.addEventListener("change", ()=>{
    $("fxOut").style.opacity = String($("fxCanvasOpacity").value);
  });
}
bindSimplePair("fxCanvasOpacity","fxCanvasOpacity_n");

/* =========================
   WebGL pipeline
========================= */
const canvas=$("fxOut");
let gl=null, prog=null, quadVBO=null;
let texA=null, texB=null;
let fbTex0=null, fbTex1=null, fbFbo0=null, fbFbo1=null, ping=0;

function createShader(gl,type,src){
  const sh=gl.createShader(type);
  gl.shaderSource(sh,src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(sh));
    gl.deleteShader(sh); return null;
  }
  return sh;
}
function createProgram(gl,vsSrc,fsSrc){
  const vs=createShader(gl,gl.VERTEX_SHADER,vsSrc);
  const fs=createShader(gl,gl.FRAGMENT_SHADER,fsSrc);
  if(!vs||!fs) return null;
  const p=gl.createProgram();
  gl.attachShader(p,vs); gl.attachShader(p,fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    gl.deleteProgram(p); return null;
  }
  gl.deleteShader(vs); gl.deleteShader(fs);
  return p;
}
const VS=`
attribute vec2 aPos;
varying vec2 vUv;
void main(){ vUv=aPos*0.5+0.5; gl_Position=vec4(aPos,0.0,1.0); }
`;

const FS = `
precision highp float;
varying vec2 vUv;

uniform sampler2D uA;
uniform sampler2D uB;
uniform sampler2D uFB;
uniform vec2 uRes;
uniform float uTime;

uniform int uHasA;
uniform int uHasB;
uniform int uUseAasB;

uniform int uBlendMode;
uniform float uBOpacity;
uniform float uInvB;

uniform float uExposure;
uniform float uContrast;
uniform float uSat;

uniform int uFeedbackOn;
uniform float uFbAmt;
uniform float uFbZoom;
uniform float uFbRot;

uniform int uKaleidoOn;
uniform float uKSeg;
uniform float uKAmt;
uniform float uKSpin;

uniform int uRGBOn;
uniform float uRGBAmt;

uniform int uGlitchOn;
uniform float uGlitchAmt;

uniform int uPixelOn;
uniform float uPixSize;

uniform int uScanOn;
uniform float uScanAmt;

uniform int uVigOn;
uniform float uVigAmt;

uniform int uFeedbackT;
uniform int uKaleidoT;
uniform int uRGBT;
uniform int uGlitchT;
uniform int uPixelT;

/* NEW: flips + mirror */
uniform int uFlipXA;
uniform int uFlipYA;
uniform int uFlipXB;
uniform int uFlipYB;
uniform int uMirrorMode;

vec3 satAdjust(vec3 c,float s){
  float l=dot(c,vec3(0.2126,0.7152,0.0722));
  return mix(vec3(l),c,s);
}
vec2 rot2(vec2 p,float a){
  float c=cos(a), s=sin(a);
  return mat2(c,-s,s,c)*p;
}
vec3 blend(vec3 a, vec3 b, int mode){
  if (mode==0) return b;
  if (mode==1) return a*b;
  if (mode==2) return 1.0-(1.0-a)*(1.0-b);
  if (mode==3) return abs(a-b);
  if (mode==4) return a+b;
  if (mode==5) return mix(2.0*a*b, 1.0-2.0*(1.0-a)*(1.0-b), step(0.5,a));
  if (mode==6) return a + b - 2.0*a*b;
  return b;
}
float hash(vec2 p){
  p=fract(p*vec2(123.34,456.21));
  p+=dot(p,p+34.345);
  return fract(p.x*p.y);
}

/* NEW: flip helper */
vec2 applyFlip(vec2 uv, int fx, int fy){
  if (fx==1) uv.x = 1.0 - uv.x;
  if (fy==1) uv.y = 1.0 - uv.y;
  return uv;
}

vec3 sampleA(vec2 uv){
  if (uHasA!=1) return vec3(0.0);
  uv = applyFlip(uv, uFlipXA, uFlipYA);
  return texture2D(uA, clamp(uv,0.0,1.0)).rgb;
}
vec3 sampleB(vec2 uv){
  uv = applyFlip(uv, uFlipXB, uFlipYB);
  if (uHasB==1) return texture2D(uB, clamp(uv,0.0,1.0)).rgb;
  if (uUseAasB==1 && uHasA==1) return texture2D(uA, clamp(uv,0.0,1.0)).rgb;
  return vec3(0.0);
}

vec3 rgbShiftFromSampler(int which, vec2 uv){
  float amt = uRGBAmt;
  vec2 off = vec2(amt, 0.0);
  vec3 c0 = (which==0) ? sampleA(uv) : sampleB(uv);
  vec3 cR = (which==0) ? sampleA(uv+off) : sampleB(uv+off);
  vec3 cB = (which==0) ? sampleA(uv-off) : sampleB(uv-off);
  return vec3(cR.r, c0.g, cB.b);
}

vec2 pixelateUv(vec2 uv){
  float px=max(1.0,uPixSize);
  return floor(uv*px)/px + 0.5/px;
}

vec2 glitchUv(vec2 uv){
  float g=uGlitchAmt;
  float t=uTime*1.2;
  float line=floor(uv.y*240.0);
  float rnd=hash(vec2(line,floor(t*6.0)));
  vec2 guv = uv;
  guv.x += (rnd-0.5)*0.02*g;
  float blockY=floor(uv.y*10.0);
  float br=hash(vec2(blockY,floor(t*3.0)));
  if (br < 0.18*g) guv.x += (br-0.09)*0.12*g;
  return guv;
}

vec2 kaleidoUv(vec2 uv){
  vec2 kp = uv - 0.5;
  float ang = atan(kp.y,kp.x);
  float r = length(kp);
  float seg = max(2.0, uKSeg);
  float k = 6.28318530718/seg;
  ang = mod(ang + uTime*uKSpin, k);
  ang = abs(ang - k*0.5);
  vec2 ku = vec2(cos(ang), sin(ang))*r;
  return ku + 0.5;
}

vec3 mixAB(vec3 A, vec3 B){
  vec3 Binv = mix(B, 1.0-B, clamp(uInvB,0.0,1.0));
  vec3 mixedB = blend(A, Binv, uBlendMode);
  return mix(A, mixedB, clamp(uBOpacity,0.0,1.0));
}

vec2 applyMirror(vec2 uv){
  if (uMirrorMode==1) uv.x = 1.0-uv.x;
  else if (uMirrorMode==2) uv.y = 1.0-uv.y;
  else if (uMirrorMode==3) uv = vec2(1.0-uv.x, 1.0-uv.y);
  return uv;
}

void main(){
  vec2 uv = applyMirror(vUv);

  vec3 A = sampleA(uv);
  vec3 B = sampleB(uv);

  if (uRGBOn==1){
    if (uRGBT==0) A = rgbShiftFromSampler(0, uv);
    else if (uRGBT==1) B = rgbShiftFromSampler(1, uv);
  }

  if (uGlitchOn==1){
    vec2 guv = glitchUv(uv);
    if (uGlitchT==0) A = sampleA(guv);
    else if (uGlitchT==1) B = sampleB(guv);
  }

  if (uKaleidoOn==1){
    vec2 kuv = kaleidoUv(uv);
    if (uKaleidoT==0) A = mix(A, sampleA(kuv), clamp(uKAmt,0.0,1.0));
    else if (uKaleidoT==1) B = mix(B, sampleB(kuv), clamp(uKAmt,0.0,1.0));
  }

  vec3 Mix = mixAB(A, B);

  if (uPixelOn==1 && uPixelT==2){
    vec2 puv = pixelateUv(uv);
    Mix = mixAB(sampleA(puv), sampleB(puv));
  }
  if (uGlitchOn==1 && uGlitchT==2){
    vec2 guv = glitchUv(uv);
    Mix = mixAB(sampleA(guv), sampleB(guv));
  }
  if (uKaleidoOn==1 && uKaleidoT==2){
    vec2 kuv = kaleidoUv(uv);
    vec3 km = mixAB(sampleA(kuv), sampleB(kuv));
    Mix = mix(Mix, km, clamp(uKAmt,0.0,1.0));
  }

  vec3 Final = Mix;

  if (uFeedbackOn==1){
    vec2 p = uv - 0.5;
    vec2 fbUv = rot2(p, uFbRot) / (1.0 + uFbZoom) + 0.5;
    vec3 fb = texture2D(uFB, fbUv).rgb;
    float a = clamp(uFbAmt,0.0,0.98);
    if (uFeedbackT==0) { A = mix(A, fb, a); Mix = mixAB(A,B); Final = Mix; }
    else if (uFeedbackT==1) { B = mix(B, fb, a); Mix = mixAB(A,B); Final = Mix; }
    else if (uFeedbackT==2) { Mix = mix(Mix, fb, a); Final = Mix; }
    else { Final = mix(Final, fb, a); }
  }

  if (uKaleidoOn==1 && uKaleidoT==3){
    vec2 kuv = kaleidoUv(uv);
    vec3 km = mixAB(sampleA(kuv), sampleB(kuv));
    Final = mix(Final, km, clamp(uKAmt,0.0,1.0));
  }

  if (uRGBOn==1 && (uRGBT==2 || uRGBT==3)){
    float amt = uRGBAmt;
    vec2 off = vec2(amt, 0.0);
    vec3 f0 = Final;
    vec3 fR = mixAB(sampleA(uv+off), sampleB(uv+off));
    vec3 fB = mixAB(sampleA(uv-off), sampleB(uv-off));
    Final = vec3(fR.r, f0.g, fB.b);
  }

  if (uGlitchOn==1 && uGlitchT==3){
    vec2 guv = glitchUv(uv);
    Final = mixAB(sampleA(guv), sampleB(guv));
  }

  if (uPixelOn==1 && uPixelT==3){
    vec2 puv = pixelateUv(uv);
    Final = mixAB(sampleA(puv), sampleB(puv));
  }

  Final *= uExposure;
  Final = (Final - 0.5)*uContrast + 0.5;
  Final = satAdjust(Final, uSat);

  if (uScanOn==1){
    float s = sin(vUv.y*uRes.y*3.14159);
    float scan = mix(1.0, 0.78 + 0.22*s, clamp(uScanAmt,0.0,1.0));
    Final *= scan;
  }
  if (uVigOn==1){
    float d = distance(vUv, vec2(0.5));
    float v = smoothstep(0.35, 0.95, d);
    Final *= mix(1.0, 1.0 - v, clamp(uVigAmt,0.0,1.0));
  }

  gl_FragColor = vec4(clamp(Final,0.0,1.0), 1.0);
}
`;

function resizeCanvas(){
  const dpr=Math.min(2, window.devicePixelRatio||1);
  const rect=canvas.getBoundingClientRect();
  const w=Math.max(2, Math.floor(rect.width*dpr));
  const h=Math.max(2, Math.floor(rect.height*dpr));
  if (canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h;
    if (gl){
      gl.viewport(0,0,w,h);
      initFeedbackTextures(w,h);
    }
  }
}
function makeTex(){
  const t=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.bindTexture(gl.TEXTURE_2D,null);
  return t;
}
function initFeedbackTextures(w,h){
  function makeFBTex(){
    const t=makeTex();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    gl.bindTexture(gl.TEXTURE_2D,null);
    return t;
  }
  function makeFBO(tex){
    const f=gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER,null);
    return f;
  }
  [fbTex0,fbTex1].forEach(t=>t&&gl.deleteTexture(t));
  [fbFbo0,fbFbo1].forEach(f=>f&&gl.deleteFramebuffer(f));
  fbTex0=makeFBTex(); fbTex1=makeFBTex();
  fbFbo0=makeFBO(fbTex0); fbFbo1=makeFBO(fbTex1);
  ping=0;
}
function initGL(){
  gl = canvas.getContext("webgl", {antialias:false, alpha:false});
  if (!gl){ $("status").textContent="Status: WebGL not supported"; return; }
  prog = createProgram(gl, VS, FS);
  if (!prog){ $("status").textContent="Status: shader compile failed"; return; }
  gl.useProgram(prog);

  quadVBO = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(prog,"aPos");
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

  texA=makeTex(); texB=makeTex();
  resizeCanvas();
}

function blendModeToInt(v){
  if (v==="normal") return 0;
  if (v==="multiply") return 1;
  if (v==="screen") return 2;
  if (v==="difference") return 3;
  if (v==="add") return 4;
  if (v==="overlay") return 5;
  if (v==="exclusion") return 6;
  return 3;
}
function targetToInt(v){
  if (v==="a") return 0;
  if (v==="b") return 1;
  if (v==="mix") return 2;
  return 3;
}
function updateVideoTexture(tex, video){
  gl.bindTexture(gl.TEXTURE_2D, tex);
  try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video); }catch(e){}
  gl.bindTexture(gl.TEXTURE_2D, null);
}

function tick(t){
  const sourceState = getFxSourceState();
  const active = !!gl && sourceState.active;
  if (active){
    resizeCanvas();

    const hasA = sourceState.hasA;
    const hasB = sourceState.hasB;
    const videoA = sourceState.videoA;
    const videoB = sourceState.videoB;

    if (hasA && videoA) updateVideoTexture(texA, videoA);
    if (hasB && videoB) updateVideoTexture(texB, videoB);

    gl.useProgram(prog);
    const w=canvas.width, h=canvas.height;

    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA);
    gl.uniform1i(gl.getUniformLocation(prog,"uA"), 0);

    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texB);
    gl.uniform1i(gl.getUniformLocation(prog,"uB"), 1);

    const prevTex = (ping===0) ? fbTex0 : fbTex1;
    const nextFbo = (ping===0) ? fbFbo1 : fbFbo0;

    gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, prevTex);
    gl.uniform1i(gl.getUniformLocation(prog,"uFB"), 2);

    gl.uniform2f(gl.getUniformLocation(prog,"uRes"), w, h);
    gl.uniform1f(gl.getUniformLocation(prog,"uTime"), t/1000);

    gl.uniform1i(gl.getUniformLocation(prog,"uHasA"), hasA?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uHasB"), hasB?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uUseAasB"), $("useAasB").checked ? 1 : 0);

    gl.uniform1i(gl.getUniformLocation(prog,"uBlendMode"), blendModeToInt($("fxBlend").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uBOpacity"), parseFloat($("fxBOpacity").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uInvB"), parseFloat($("fxInvB").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uExposure"), parseFloat($("fxExposure").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uContrast"), parseFloat($("fxContrast").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uSat"), parseFloat($("fxSat").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uFeedbackOn"), $("tFeedback").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uFbAmt"), parseFloat($("feedbackAmt").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uFbZoom"), parseFloat($("feedbackZoom").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uFbRot"), parseFloat($("feedbackRot").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uKaleidoOn"), $("tKaleido").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uKSeg"), parseFloat($("kSeg").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uKAmt"), parseFloat($("kAmt").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uKSpin"), parseFloat($("kSpin").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uRGBOn"), $("tRGB").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uRGBAmt"), parseFloat($("rgbAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uGlitchOn"), $("tGlitch").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uGlitchAmt"), parseFloat($("glitchAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uPixelOn"), $("tPixel").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uPixSize"), parseFloat($("pixSize").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uScanOn"), $("tScan").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uScanAmt"), parseFloat($("scanAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uVigOn"), $("tVig").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uVigAmt"), parseFloat($("vigAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uFeedbackT"), targetToInt($("feedbackTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uKaleidoT"), targetToInt($("kaleidoTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uRGBT"), targetToInt($("rgbTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uGlitchT"), targetToInt($("glitchTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uPixelT"), targetToInt($("pixelTarget").value));

    // NEW: flips + mirror
    gl.uniform1i(gl.getUniformLocation(prog,"uFlipXA"), $("flipXA").checked ? 1 : 0);
    gl.uniform1i(gl.getUniformLocation(prog,"uFlipYA"), $("flipYA").checked ? 1 : 0);
    gl.uniform1i(gl.getUniformLocation(prog,"uFlipXB"), $("flipXB").checked ? 1 : 0);
    gl.uniform1i(gl.getUniformLocation(prog,"uFlipYB"), $("flipYB").checked ? 1 : 0);
    gl.uniform1i(gl.getUniformLocation(prog,"uMirrorMode"), parseInt($("mirrorMode").value,10) || 0);

    gl.bindFramebuffer(gl.FRAMEBUFFER, nextFbo);
    gl.viewport(0,0,w,h);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    ping = 1-ping;
    const nowTex = (ping===0) ? fbTex0 : fbTex1;

    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, nowTex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,w,h);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // keep canvas style in sync
    $("fxOut").style.mixBlendMode = $("fxCanvasBlend").value;
    $("fxOut").style.opacity = String($("fxCanvasOpacity").value);
  }

  requestAnimationFrame(tick);
}

/* =========================
   Boot
========================= */
function resizeOnWindow(){ resizeCanvas(); }
window.addEventListener("resize", resizeOnWindow);

document.addEventListener("DOMContentLoaded", async ()=>{
  initGL();
  initAllPairs();

  initDefaultDecks();
  renderDecks();

  rebuildLinkLayers();
  updateQuickButtons();

  // preload default decks
  $("deckStatus").textContent = "Decks: loading…";
  for (const k of Object.keys(decks)){
    await loadDeck(k);
  }
  renderDecks();
  $("deckStatus").textContent = "Decks: loaded";

  // initial random if possible
  if (decks[DEFAULT_DECK_KEY]?.items?.length){
    pickRandomIntoLayer(0);
    pickRandomIntoLayer(1);
    $("status").textContent = `Status: ready`;
  } else {
    $("status").textContent = "Status: load a deck";
  }

  // start render loop
  requestAnimationFrame(tick);
});
</script>
</body>
</html>
