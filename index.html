<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>VJ Mixer (Links) + FX Capture (Tab/Window) w/ Deck + Random + Targeted FX</title>
  <style>
    :root{
      --bg:#07080c; --panel:#0f1118; --panel2:#0b0d13;
      --text:#e9edf6; --muted:#9aa3b5; --border:rgba(255,255,255,.12);
      --accent:#7aa2ff; --radius:16px; --maxw:1280px;
    }
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    .wrap{max-width:var(--maxw);margin:16px auto;padding:0 14px;display:grid;gap:12px;}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .title{display:grid;gap:4px}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .sub{font-size:12px;color:var(--muted);line-height:1.25}
    .actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      color:var(--text);
      border-radius:999px;
      padding:10px 14px;
      font-size:14px;
      cursor:pointer;
    }
    button.primary{
      border-color:rgba(122,162,255,.55);
      box-shadow:0 0 0 2px rgba(122,162,255,.10) inset;
    }
    button.danger{border-color:rgba(255,130,130,.5)}
    button:active{transform:translateY(1px)}
    .seg{display:flex; gap:6px; padding:6px; border:1px solid var(--border); background:rgba(255,255,255,.03); border-radius:999px;}
    .seg button{border-radius:999px; padding:8px 12px; border:1px solid transparent; background:transparent;}
    .seg button.active{background:rgba(122,162,255,.18); border-color:rgba(122,162,255,.35);}

    .stage{
      position:relative; width:100%; aspect-ratio:16/9;
      border-radius:var(--radius); overflow:hidden; border:1px solid var(--border);
      background:#000; isolation:isolate;
    }
    .layersRoot{position:absolute; inset:0; z-index:10;}
    .layer{position:absolute; inset:0; pointer-events:none; will-change:opacity,filter,transform; mix-blend-mode:normal; opacity:1; overflow:hidden;}
    .layerInner{position:absolute; inset:0; transform-origin:center center; will-change:transform;}
    .layer iframe{width:100%;height:100%;border:0;display:block; background:#000;}
    canvas#fxOut{position:absolute; inset:0; width:100%; height:100%; display:none; z-index:30;}
    .fxOverlay{
      position:absolute; inset:0; z-index:40;
      display:none;
      background:radial-gradient(1200px 700px at 50% 40%, rgba(122,162,255,.14), rgba(0,0,0,.85));
      align-items:center; justify-content:center; text-align:center; padding:16px;
    }
    .fxOverlay .box{
      border:1px solid var(--border);
      background:rgba(0,0,0,.35);
      border-radius:18px;
      padding:16px 18px;
      max-width:520px;
      box-shadow:0 0 0 2px rgba(122,162,255,.08) inset;
    }
    .fxOverlay .big{font-weight:800;letter-spacing:.2px;margin-bottom:6px}
    .fxOverlay .small{color:var(--muted);font-size:12px;line-height:1.3}

    .controls{background:rgba(255,255,255,.03); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden;}
    .controlsHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap; padding:12px; border-bottom:1px solid var(--border);}
    .badge{font-size:12px;color:var(--muted); border:1px solid var(--border); padding:4px 10px;border-radius:999px;background:rgba(255,255,255,.02);}
    .controlsBody{display:none;padding:12px;gap:12px}
    .controls.open .controlsBody{display:grid;}
    .grid{display:grid;grid-template-columns: 1fr 1fr; gap:12px;}
    @media (max-width: 980px){.grid{grid-template-columns: 1fr;}}
    .card{border:1px solid var(--border); border-radius:var(--radius); background:rgba(0,0,0,.22); overflow:hidden;}
    .cardHead{padding:10px 12px; border-bottom:1px solid var(--border); display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}
    .cardTitle{font-weight:700;font-size:13px}
    .cardBody{padding:12px;display:grid;gap:10px}
    label{display:grid;gap:6px;font-size:12px;color:var(--muted);}
    input[type="text"], select{
      width:100%; padding:10px; border-radius:12px; border:1px solid var(--border);
      background:rgba(0,0,0,.30); color:var(--text); font-size:14px; outline:none;
    }
    input[type="range"]{width:100%;}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width: 740px){.row{grid-template-columns:1fr;}}
    .toggle{display:flex;gap:8px;align-items:center;color:var(--muted);font-size:12px;user-select:none}
    .toggle input{transform:scale(1.05)}
    .miniBtns{display:flex;gap:8px;flex-wrap:wrap}
    .miniBtns button{padding:8px 10px;font-size:12px}
    .small{font-size:12px;color:var(--muted);line-height:1.25}
    .layerList{display:grid;gap:10px}
    .layerItem{border:1px solid var(--border);border-radius:14px;background:rgba(255,255,255,.02);overflow:hidden}
    .layerItemHead{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;padding:10px 12px;border-bottom:1px solid var(--border);}
    .layerItemHead .name{font-weight:700;font-size:13px}
    .layerItemBody{padding:12px;display:grid;gap:10px}

    .valRow{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .val{font-variant-numeric:tabular-nums; font-size:12px; color:var(--text); opacity:.9}

    /* Deck */
    .deckTabs{display:flex;gap:6px;flex-wrap:wrap}
    .deckTabs button{padding:7px 10px;font-size:12px}
    .deckTabs button.active{background:rgba(122,162,255,.18);border-color:rgba(122,162,255,.35)}
    .deckGrid{
      display:grid;
      grid-template-columns:repeat(3,1fr);
      gap:10px;
      max-height:420px;
      overflow:auto;
      padding-right:4px;
    }
    @media (max-width: 980px){.deckGrid{grid-template-columns:repeat(4,1fr)}}
    @media (max-width: 640px){.deckGrid{grid-template-columns:repeat(3,1fr)}}
    .thumb{
      border:1px solid var(--border);
      border-radius:12px;
      overflow:hidden;
      background:rgba(0,0,0,.25);
      cursor:pointer;
      display:grid;
      gap:0;
    }
    .thumb img{width:100%;display:block;aspect-ratio:16/9;object-fit:cover;background:#000}
    .thumb .cap{padding:7px 8px;font-size:11px;color:var(--muted);line-height:1.2;max-height:2.5em;overflow:hidden}
    .deckBar{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pill{
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      background:rgba(255,255,255,.02);
      font-size:12px;
      color:var(--muted);
    }
    .help{font-size:12px;color:var(--muted);line-height:1.25}
    .hr{height:1px;background:var(--border);margin:6px 0}
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">
      <h1>VJ Mixer</h1>
      <div class="sub">
        <b>Link Mixer</b> = multiple YouTube embeds (blend + CSS transforms). <b>FX Capture</b> = capture tab/window pixels → real WebGL FX.
        (Per-source Flip/Rotate fixes upside-down/backwards.)
      </div>
    </div>
    <div class="actions">
      <div class="seg">
        <button id="tabLinks" class="active">Link Mixer</button>
        <button id="tabFX">FX Capture</button>
      </div>
      <button id="btnToggleControls">Show Controls</button>
    </div>
  </div>

  <div class="stage" id="stage">
    <div class="layersRoot" id="layersRoot"></div>
    <canvas id="fxOut"></canvas>

    <div class="fxOverlay" id="fxOverlay">
      <div class="box">
        <div class="big">FX Capture ready</div>
        <div class="small">
          Click <b>Capture A</b> (and optionally <b>Capture B</b>) to select a tab/window.<br/>
          Chrome’s “sharing” banner can’t be hidden (browser security), but fullscreen/theater helps keep it out of the video area.
        </div>
      </div>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="controlsHead">
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <span class="badge" id="modeBadge">Mode: Link Mixer</span>
        <span class="badge" id="status">Status: idle</span>
      </div>
      <div class="small">Tip: In capture mode, put YouTube in fullscreen/theater for “mostly just video”.</div>
    </div>

    <div class="controlsBody" id="controlsBody">
      <!-- LINKS MODE -->
      <div id="modeLinks" style="display:block;">
        <div class="grid">
          <div class="card">
            <div class="cardHead">
              <div class="cardTitle">Links (2–5)</div>
              <div class="miniBtns">
                <button id="addLayer">Add</button>
                <button id="removeLayer" class="danger">Remove</button>
                <button id="reloadLinks">Reload</button>
              </div>
            </div>
            <div class="cardBody">
              <label>Tap-through YouTube UI
                <select id="tapUI">
                  <option value="off" selected>off (recommended)</option>
                  <option value="on">on</option>
                </select>
              </label>

              <div class="row">
                <label>Deck: click a thumbnail → send to layer
                  <select id="deckTargetLayer"></select>
                </label>
                <label>Deck filter
                  <input id="deckFilter" type="text" placeholder="type to filter titles…"/>
                </label>
              </div>

              <div class="layerList" id="layerList"></div>
            </div>
          </div>

          <div class="card">
            <div class="cardHead">
              <div class="cardTitle">Video Deck (your playlists)</div>
              <div class="deckTabs" id="deckTabs"></div>
            </div>
            <div class="cardBody">
              <div class="deckBar">
                <span class="pill" id="deckStatus">Deck: loading…</span>
                <button id="deckRefresh">Refresh</button>
              </div>
              <div class="help">
                This deck is built from the playlist RSS (via a CORS-friendly text proxy). Click any thumbnail to load it into your chosen layer.
              </div>
              <div class="hr"></div>
              <div class="deckGrid" id="deckGrid"></div>
              <div class="help" style="margin-top:8px">
                <b>Note:</b> Link Mixer can’t do “real” pixel FX on YouTube (cross-origin). Use FX Capture for trails/kaleido/glitch.
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- FX MODE -->
      <div id="modeFX" style="display:none;">
        <div class="grid">
          <div class="card">
            <div class="cardHead">
              <div class="cardTitle">Capture + Source Setup</div>
              <div class="miniBtns">
                <button id="capA" class="primary">Capture A</button>
                <button id="capB" class="primary">Capture B</button>
                <button id="stopCap">Stop</button>
                <button id="fitA">Auto-fit A</button>
                <button id="fitB">Auto-fit B</button>
              </div>
            </div>
            <div class="cardBody">
              <div class="small">
                “Auto-fit” matches the crop to the captured source aspect ratio (best possible auto-crop).
                It can’t detect the exact player area inside the tab UI—fullscreen/theater helps.
              </div>

              <div class="card" style="background:rgba(255,255,255,.01)">
                <div class="cardHead"><div class="cardTitle">A Transform (fix upside-down/backwards)</div></div>
                <div class="cardBody">
                  <div class="row">
                    <label class="toggle"><input id="aFlipV" type="checkbox" checked> Flip Vertical (default ON)</label>
                    <label class="toggle"><input id="aFlipH" type="checkbox"> Flip Horizontal</label>
                  </div>
                  <label>Rotate
                    <select id="aRot">
                      <option value="0" selected>0°</option>
                      <option value="90">90°</option>
                      <option value="180">180°</option>
                      <option value="270">270°</option>
                    </select>
                  </label>
                  <div class="row">
                    <label>Center X <input id="aCx" type="range" min="0" max="1" step="0.001" value="0.5"></label>
                    <label>Center Y <input id="aCy" type="range" min="0" max="1" step="0.001" value="0.5"></label>
                  </div>
                  <label>Zoom <input id="aZoom" type="range" min="1" max="6" step="0.01" value="1.75"></label>
                </div>
              </div>

              <div class="card" style="background:rgba(255,255,255,.01)">
                <div class="cardHead"><div class="cardTitle">B Transform</div></div>
                <div class="cardBody">
                  <div class="row">
                    <label class="toggle"><input id="bFlipV" type="checkbox" checked> Flip Vertical (default ON)</label>
                    <label class="toggle"><input id="bFlipH" type="checkbox"> Flip Horizontal</label>
                  </div>
                  <label>Rotate
                    <select id="bRot">
                      <option value="0" selected>0°</option>
                      <option value="90">90°</option>
                      <option value="180">180°</option>
                      <option value="270">270°</option>
                    </select>
                  </label>
                  <div class="row">
                    <label>Center X <input id="bCx" type="range" min="0" max="1" step="0.001" value="0.5"></label>
                    <label>Center Y <input id="bCy" type="range" min="0" max="1" step="0.001" value="0.5"></label>
                  </div>
                  <label>Zoom <input id="bZoom" type="range" min="1" max="6" step="0.01" value="1.75"></label>

                  <div class="row">
                    <label class="toggle"><input id="useAasB" type="checkbox"> If B missing, use A as B</label>
                    <label>Invert B <input id="fxInvB" type="range" min="0" max="1" step="0.01" value="1"></label>
                  </div>
                </div>
              </div>

              <div class="row">
                <label>Blend (B over A)
                  <select id="fxBlend">
                    <option value="difference" selected>difference</option>
                    <option value="screen">screen</option>
                    <option value="add">add</option>
                    <option value="multiply">multiply</option>
                    <option value="overlay">overlay</option>
                    <option value="exclusion">exclusion</option>
                    <option value="normal">normal</option>
                  </select>
                </label>
                <label>B Opacity <input id="fxBOpacity" type="range" min="0" max="1" step="0.01" value="0.85"></label>
              </div>

              <div class="row">
                <label>Exposure <input id="fxExposure" type="range" min="0.5" max="2.5" step="0.01" value="1.05"></label>
                <label>Contrast <input id="fxContrast" type="range" min="0.5" max="3.0" step="0.01" value="1.35"></label>
              </div>
              <label>Saturation <input id="fxSat" type="range" min="0" max="3" step="0.01" value="1.25"></label>
            </div>
          </div>

          <div class="card">
            <div class="cardHead">
              <div class="cardTitle">FX (targeted + exact values)</div>
              <div class="miniBtns"><button id="fxAllOff">All FX Off</button></div>
            </div>
            <div class="cardBody">
              <div class="row">
                <label class="toggle"><input id="tFeedback" type="checkbox"> Feedback / Trails</label>
                <label>Affect
                  <select id="feedbackTarget">
                    <option value="final" selected>Final</option>
                    <option value="mix">Mix</option>
                    <option value="a">A</option>
                    <option value="b">B</option>
                  </select>
                </label>
              </div>
              <label>
                <div class="valRow"><span>Amount</span><span class="val" data-valfor="feedbackAmt"></span></div>
                <input id="feedbackAmt" type="range" min="0" max="0.98" step="0.001" value="0.88">
              </label>
              <label>
                <div class="valRow"><span>Zoom</span><span class="val" data-valfor="feedbackZoom"></span></div>
                <input id="feedbackZoom" type="range" min="-0.08" max="0.12" step="0.001" value="0.06">
              </label>
              <label>
                <div class="valRow"><span>Rotate</span><span class="val" data-valfor="feedbackRot"></span></div>
                <input id="feedbackRot" type="range" min="-2.5" max="2.5" step="0.01" value="0.12">
              </label>

              <div class="row">
                <label class="toggle"><input id="tKaleido" type="checkbox"> Kaleido / Mirror</label>
                <label>Affect
                  <select id="kaleidoTarget">
                    <option value="final" selected>Final</option>
                    <option value="mix">Mix</option>
                    <option value="a">A</option>
                    <option value="b">B</option>
                  </select>
                </label>
              </div>
              <label>
                <div class="valRow"><span>Segments</span><span class="val" data-valfor="kSeg"></span></div>
                <input id="kSeg" type="range" min="2" max="16" step="1" value="6">
              </label>
              <label>
                <div class="valRow"><span>Amount</span><span class="val" data-valfor="kAmt"></span></div>
                <input id="kAmt" type="range" min="0" max="1" step="0.01" value="0.85">
              </label>
              <label>
                <div class="valRow"><span>Spin</span><span class="val" data-valfor="kSpin"></span></div>
                <input id="kSpin" type="range" min="-3" max="3" step="0.01" value="0.35">
              </label>

              <div class="row">
                <label class="toggle"><input id="tRGB" type="checkbox"> RGB Shift</label>
                <label>Affect
                  <select id="rgbTarget">
                    <option value="b" selected>B</option>
                    <option value="a">A</option>
                    <option value="mix">Mix</option>
                    <option value="final">Final</option>
                  </select>
                </label>
              </div>
              <label>
                <div class="valRow"><span>Amount</span><span class="val" data-valfor="rgbAmt"></span></div>
                <input id="rgbAmt" type="range" min="0" max="0.05" step="0.0005" value="0.012">
              </label>

              <div class="row">
                <label class="toggle"><input id="tGlitch" type="checkbox"> Glitch</label>
                <label>Affect
                  <select id="glitchTarget">
                    <option value="mix" selected>Mix</option>
                    <option value="final">Final</option>
                    <option value="a">A</option>
                    <option value="b">B</option>
                  </select>
                </label>
              </div>
              <label>
                <div class="valRow"><span>Amount</span><span class="val" data-valfor="glitchAmt"></span></div>
                <input id="glitchAmt" type="range" min="0" max="1" step="0.01" value="0.35">
              </label>

              <div class="row">
                <label class="toggle"><input id="tPixel" type="checkbox"> Pixelate</label>
                <label>Affect
                  <select id="pixelTarget">
                    <option value="final" selected>Final</option>
                    <option value="mix">Mix</option>
                    <option value="a">A</option>
                    <option value="b">B</option>
                  </select>
                </label>
              </div>
              <label>
                <div class="valRow"><span>Size</span><span class="val" data-valfor="pixSize"></span></div>
                <input id="pixSize" type="range" min="1" max="220" step="1" value="70">
              </label>

              <div class="row">
                <label class="toggle"><input id="tScan" type="checkbox"> Scanlines</label>
                <label class="toggle"><input id="tVig" type="checkbox"> Vignette</label>
              </div>
              <label>
                <div class="valRow"><span>Scan amount</span><span class="val" data-valfor="scanAmt"></span></div>
                <input id="scanAmt" type="range" min="0" max="1" step="0.01" value="0.35">
              </label>
              <label>
                <div class="valRow"><span>Vignette amount</span><span class="val" data-valfor="vigAmt"></span></div>
                <input id="vigAmt" type="range" min="0" max="1" step="0.01" value="0.55">
              </label>

              <div class="small">If capture looks flipped: toggle Flip V / Flip H and Rotate until correct.</div>
            </div>
          </div>
        </div>
      </div><!-- /modeFX -->
    </div>
  </div>
</div>

<script>
const $ = (id)=>document.getElementById(id);

/* =========================
   Mode + Controls
========================= */
let currentMode = "links";
function setMode(mode){
  currentMode = mode;
  $("tabLinks").classList.toggle("active", mode==="links");
  $("tabFX").classList.toggle("active", mode==="fx");
  $("modeBadge").textContent = mode==="links" ? "Mode: Link Mixer" : "Mode: FX Capture";
  $("layersRoot").style.display = mode==="links" ? "block" : "none";
  $("fxOut").style.display = mode==="fx" ? "block" : "none";
  $("modeLinks").style.display = mode==="links" ? "block" : "none";
  $("modeFX").style.display = mode==="fx" ? "block" : "none";
  $("status").textContent = "Status: " + (mode==="links" ? "Link Mixer ready" : "FX Capture ready");
  $("fxOverlay").style.display = (mode==="fx" && !capStreamA && !capStreamB) ? "flex" : "none";
  resizeCanvas();
}
$("tabLinks").addEventListener("click", ()=>setMode("links"));
$("tabFX").addEventListener("click", ()=>setMode("fx"));

const controls = $("controls");
$("btnToggleControls").addEventListener("click", ()=>{
  controls.classList.toggle("open");
  $("btnToggleControls").textContent = controls.classList.contains("open") ? "Hide Controls" : "Show Controls";
});
controls.classList.remove("open");
$("btnToggleControls").textContent = "Show Controls";

/* =========================
   MODE 1: Link Mixer (no real FX)
   - Adds per-layer CSS Zoom/Pan
   - Adds playlist random + per-layer auto random timer
   - Adds Deck thumbnails from playlist feeds
========================= */

const DEFAULT_LINKS = [
  "https://www.youtube.com/watch?v=3pxrECZYEAA",
  "https://www.youtube.com/watch?v=dS-MaUk6YBI"
];

const PLAYLISTS = [
  { key:"trippy",    name:"Trippy visuals", listId:"PLuyTQuSXZ5EUeHHskJJmWqicuyKJK4kc2" },
  { key:"cartoons",  name:"Cartoons",      listId:"PL1ZB2TfCq41TxhYoCOeYiwONkig6Lt_C3" },
  { key:"ads",       name:"Old commercials",listId:"PLxqMsrhM_WC25QOMHMQp-Cm9k6nfc_vPu" },
];

/* A small trick: YouTube RSS often has no CORS, so we fetch through a text proxy */
function rssProxyUrl(listId){
  // r.jina.ai returns the remote content as plain text without browser CORS blocks
  return `https://r.jina.ai/https://www.youtube.com/feeds/videos.xml?playlist_id=${encodeURIComponent(listId)}`;
}

const BLENDS = [
  "normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn",
  "hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"
];

let linkLayerCount = 2;
const linkLayers = []; // {el, inner, iframe, ui, url, timers}
const playlistCache = new Map(); // key -> {items:[{id,title}], ts}

/* Embed helper */
function extractVideoId(url){
  if (!url) return null;
  const raw = url.trim();
  if (/^[a-zA-Z0-9_-]{11}$/.test(raw)) return raw;
  try{
    const u = new URL(raw);
    if (u.hostname.includes("youtu.be")) return u.pathname.replace("/","") || null;
    const v = u.searchParams.get("v");
    if (v) return v;
  }catch(e){}
  return null;
}

/* NOTE: This uses the normal youtube embed (not nocookie) because in practice
   it's less likely to trip “bot-ish” behavior than constantly reloading the nocookie embed.
   Also: we keep reloads user-driven or timer-driven, not spammy. */
function buildEmbedSrc(videoId){
  // loop the single video by using playlist=VIDEOID
  return `https://www.youtube.com/embed/${videoId}?playsinline=1&autoplay=1&mute=1&controls=0&rel=0&modestbranding=1&iv_load_policy=3&loop=1&playlist=${videoId}`;
}

function fillBlendOptions(sel, def="difference"){
  sel.innerHTML = BLENDS.map(b=>`<option value="${b}">${b}</option>`).join("");
  sel.value = def;
}

function makeLinkLayer(i){
  const el = document.createElement("div");
  el.className = "layer";
  el.style.zIndex = String(10 + i);
  const inner = document.createElement("div");
  inner.className = "layerInner";
  el.appendChild(inner);
  $("layersRoot").appendChild(el);
  return {el, inner};
}

function applyLinkStyle(i){
  const L = linkLayers[i];
  if (!L) return;
  const tap = $("tapUI").value === "on";
  L.el.style.pointerEvents = tap ? "auto" : "none";
  L.el.style.opacity = L.ui.op;
  L.el.style.mixBlendMode = L.ui.blend;

  // CSS-only “FX” for link mixer (safe): filter + transforms
  L.el.style.filter = `invert(${L.ui.inv}) contrast(${L.ui.ct}) saturate(${L.ui.sat}) hue-rotate(${L.ui.hue}deg)`;

  // Zoom + pan (CSS transform). Pan is in normalized 0..1 around center.
  const z = Math.max(1, L.ui.zoom);
  const px = (L.ui.cx - 0.5) * -100; // invert so moving slider right reveals right
  const py = (L.ui.cy - 0.5) * -100;
  // scale then translate slightly; translate is smaller at low zoom, bigger at high zoom
  const panScale = (z - 1) * 1.2; // “feel” factor
  L.inner.style.transform = `translate(${px*panScale}%, ${py*panScale}%) scale(${z})`;
}

function mountLinkIframe(i){
  const L = linkLayers[i];
  const vid = extractVideoId(L.url);
  if (!vid){ L.inner.innerHTML=""; return; }
  const src = buildEmbedSrc(vid);

  // Keep a stable iframe element when possible (reduces “bot-ish” thrash)
  if (!L.iframe){
    const ifr = document.createElement("iframe");
    ifr.allow = "autoplay; encrypted-media; picture-in-picture";
    ifr.referrerPolicy = "origin-when-cross-origin";
    ifr.src = src;
    L.iframe = ifr;
    L.inner.innerHTML = "";
    L.inner.appendChild(ifr);
  } else {
    // only update src if changed
    if (L.iframe.src !== src) L.iframe.src = src;
  }
}

function pickRandomFrom(items){
  if (!items || !items.length) return null;
  return items[Math.floor(Math.random()*items.length)];
}

async function loadPlaylistItems(plKey){
  const pl = PLAYLISTS.find(p=>p.key===plKey);
  if (!pl) return {items:[], err:"unknown playlist"};
  const cached = playlistCache.get(plKey);
  if (cached && cached.items && cached.items.length) return cached;

  $("deckStatus").textContent = "Deck: loading…";
  try{
    const url = rssProxyUrl(pl.listId);
    const txt = await (await fetch(url, {cache:"no-store"})).text();

    // Parse: entries contain <yt:videoId>VIDEO</yt:videoId> and <title>...</title>
    const items = [];
    const entryRe = /<entry>[\s\S]*?<\/entry>/g;
    const vidRe = /<yt:videoId>([^<]+)<\/yt:videoId>/;
    const titleRe = /<title>([^<]+)<\/title>/;

    const entries = txt.match(entryRe) || [];
    for (const e of entries){
      const m1 = e.match(vidRe);
      if (!m1) continue;
      const id = (m1[1]||"").trim();
      if (!/^[a-zA-Z0-9_-]{11}$/.test(id)) continue;

      const m2 = e.match(titleRe);
      const title = (m2 ? m2[1] : id).trim();
      items.push({id, title});
    }

    // De-dupe just in case
    const seen = new Set();
    const uniq = items.filter(it=>{
      if (seen.has(it.id)) return false;
      seen.add(it.id);
      return true;
    });

    const data = {items: uniq, ts: Date.now()};
    playlistCache.set(plKey, data);
    return data;
  }catch(err){
    return {items:[], err:String(err)};
  }finally{
    updateDeckStatus();
  }
}

/* Per-layer random */
async function setLayerFromPlaylistRandom(i, plKey){
  const L = linkLayers[i];
  if (!L) return;
  const data = await loadPlaylistItems(plKey);
  if (!data.items.length){
    $("status").textContent = `Status: deck failed (${plKey})`;
    return;
  }
  const it = pickRandomFrom(data.items);
  if (!it) return;
  L.url = `https://www.youtube.com/watch?v=${it.id}`;
  mountLinkIframe(i);
  applyLinkStyle(i);
  rebuildLinkUI(false);
  $("status").textContent = `Status: Layer ${i+1} ← random (${plKey})`;
}

function stopLayerAuto(i){
  const L = linkLayers[i];
  if (!L) return;
  if (L.autoTimer) clearInterval(L.autoTimer);
  L.autoTimer = null;
}
function startLayerAuto(i){
  const L = linkLayers[i];
  if (!L) return;
  stopLayerAuto(i);
  const ms = Math.max(5, parseInt(L.ui.autoSec,10)||30) * 1000;
  if (!L.ui.autoOn) return;
  L.autoTimer = setInterval(()=>{
    if (L.ui.randMode === "off") return;
    setLayerFromPlaylistRandom(i, L.ui.randMode);
  }, ms);
}

function rebuildLayerSelect(){
  const sel = $("deckTargetLayer");
  sel.innerHTML = "";
  for (let i=0;i<linkLayerCount;i++){
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = `Layer ${i+1}`;
    sel.appendChild(opt);
  }
}

function rebuildLinkUI(rebuildDeckTarget=true){
  const list = $("layerList");
  list.innerHTML = "";
  for (let i=0;i<linkLayerCount;i++){
    const item = document.createElement("div");
    item.className="layerItem";
    item.innerHTML = `
      <div class="layerItemHead">
        <div class="name">Layer ${i+1}</div>
        <div class="miniBtns">
          <button data-act="apply" data-i="${i}">Apply</button>
          <button data-act="rand" data-i="${i}">Random Now</button>
        </div>
      </div>
      <div class="layerItemBody">
        <label>YouTube URL or ID <input type="text" data-f="url" data-i="${i}"/></label>

        <div class="row">
          <label>Opacity <input type="range" min="0" max="1" step="0.01" data-f="op" data-i="${i}"/></label>
          <label>Blend <select data-f="blend" data-i="${i}"></select></label>
        </div>

        <div class="row">
          <label>Invert <input type="range" min="0" max="1" step="0.01" data-f="inv" data-i="${i}"/></label>
          <label>Contrast <input type="range" min="0.5" max="3" step="0.01" data-f="ct" data-i="${i}"/></label>
        </div>
        <div class="row">
          <label>Saturation <input type="range" min="0" max="3" step="0.01" data-f="sat" data-i="${i}"/></label>
          <label>Hue rotate <input type="range" min="-180" max="180" step="1" data-f="hue" data-i="${i}"/></label>
        </div>

        <div class="card" style="background:rgba(255,255,255,.01)">
          <div class="cardHead"><div class="cardTitle">Crop / Zoom (CSS)</div></div>
          <div class="cardBody">
            <div class="row">
              <label>Center X <input type="range" min="0" max="1" step="0.001" data-f="cx" data-i="${i}"/></label>
              <label>Center Y <input type="range" min="0" max="1" step="0.001" data-f="cy" data-i="${i}"/></label>
            </div>
            <label>Zoom <input type="range" min="1" max="4" step="0.01" data-f="zoom" data-i="${i}"/></label>
          </div>
        </div>

        <div class="card" style="background:rgba(255,255,255,.01)">
          <div class="cardHead"><div class="cardTitle">Random Mode + Auto Timer</div></div>
          <div class="cardBody">
            <div class="row">
              <label>Random source
                <select data-f="randMode" data-i="${i}">
                  <option value="off">off</option>
                  <option value="trippy">Trippy visuals</option>
                  <option value="cartoons">Cartoons</option>
                  <option value="ads">Old commercials</option>
                </select>
              </label>
              <label class="toggle"><input type="checkbox" data-f="autoOn" data-i="${i}"> Auto-random</label>
            </div>
            <label>Auto interval (seconds)
              <input type="range" min="5" max="600" step="1" data-f="autoSec" data-i="${i}"/>
            </label>
            <div class="small">Tip: enable Auto-random, then it will pick a new random video from that playlist every N seconds.</div>
          </div>
        </div>
      </div>
    `;
    list.appendChild(item);

    const L = linkLayers[i];
    item.querySelector(`[data-f="url"][data-i="${i}"]`).value = L.url;

    item.querySelector(`[data-f="op"][data-i="${i}"]`).value = L.ui.op;
    item.querySelector(`[data-f="inv"][data-i="${i}"]`).value = L.ui.inv;
    item.querySelector(`[data-f="ct"][data-i="${i}"]`).value = L.ui.ct;
    item.querySelector(`[data-f="sat"][data-i="${i}"]`).value = L.ui.sat;
    item.querySelector(`[data-f="hue"][data-i="${i}"]`).value = L.ui.hue;

    item.querySelector(`[data-f="cx"][data-i="${i}"]`).value = L.ui.cx;
    item.querySelector(`[data-f="cy"][data-i="${i}"]`).value = L.ui.cy;
    item.querySelector(`[data-f="zoom"][data-i="${i}"]`).value = L.ui.zoom;

    item.querySelector(`[data-f="randMode"][data-i="${i}"]`).value = L.ui.randMode;
    item.querySelector(`[data-f="autoOn"][data-i="${i}"]`).checked = !!L.ui.autoOn;
    item.querySelector(`[data-f="autoSec"][data-i="${i}"]`).value = L.ui.autoSec;

    const sel = item.querySelector(`select[data-f="blend"][data-i="${i}"]`);
    fillBlendOptions(sel, L.ui.blend);
  }

  if (rebuildDeckTarget) rebuildLayerSelect();
}

function rebuildLinkLayers(){
  // clear timers
  for (const L of linkLayers) stopLayerAuto(linkLayers.indexOf(L));

  $("layersRoot").innerHTML="";
  linkLayers.length=0;

  for (let i=0;i<linkLayerCount;i++){
    const made = makeLinkLayer(i);
    linkLayers.push({
      el: made.el,
      inner: made.inner,
      iframe: null,
      url: DEFAULT_LINKS[i] || DEFAULT_LINKS[1],
      ui: {
        op: i===0?1:0.85,
        blend: i===0?"normal":"difference",
        inv: i===0?0:1,
        ct: i===0?1:1.6,
        sat: i===0?1:1.2,
        hue: 0,

        // CSS crop/zoom defaults
        cx: 0.5,
        cy: 0.5,
        zoom: 1.0,

        // Random defaults
        randMode: "off",
        autoOn: false,
        autoSec: 30
      },
      autoTimer: null
    });
    mountLinkIframe(i);
    applyLinkStyle(i);
  }

  rebuildLinkUI(true);
  rebuildDeckTabs();
  setDeckTab(PLAYLISTS[0].key);
}

$("addLayer").addEventListener("click", ()=>{ if (linkLayerCount<5){ linkLayerCount++; rebuildLinkLayers(); }});
$("removeLayer").addEventListener("click", ()=>{ if (linkLayerCount>2){ linkLayerCount--; rebuildLinkLayers(); }});
$("reloadLinks").addEventListener("click", ()=>{
  for (let i=0;i<linkLayerCount;i++){
    mountLinkIframe(i);
    applyLinkStyle(i);
  }
});
$("tapUI").addEventListener("change", ()=>{ for (let i=0;i<linkLayerCount;i++) applyLinkStyle(i); });

$("layerList").addEventListener("input", (e)=>{
  const t=e.target;
  const i=parseInt(t.getAttribute("data-i"),10);
  const f=t.getAttribute("data-f");
  if (Number.isNaN(i)||!f) return;
  const L=linkLayers[i]; if (!L) return;

  if (f==="url") L.url=t.value;
  if (f==="op") L.ui.op=parseFloat(t.value);
  if (f==="blend") L.ui.blend=t.value;
  if (f==="inv") L.ui.inv=parseFloat(t.value);
  if (f==="ct") L.ui.ct=parseFloat(t.value);
  if (f==="sat") L.ui.sat=parseFloat(t.value);
  if (f==="hue") L.ui.hue=parseInt(t.value,10);

  if (f==="cx") L.ui.cx=parseFloat(t.value);
  if (f==="cy") L.ui.cy=parseFloat(t.value);
  if (f==="zoom") L.ui.zoom=parseFloat(t.value);

  if (f==="randMode") L.ui.randMode=t.value;
  if (f==="autoOn") L.ui.autoOn=!!t.checked;
  if (f==="autoSec") L.ui.autoSec=parseInt(t.value,10)||30;

  applyLinkStyle(i);

  // timer changes
  if (f==="randMode" || f==="autoOn" || f==="autoSec"){
    startLayerAuto(i);
  }
});

$("layerList").addEventListener("click", (e)=>{
  const btn=e.target.closest("button[data-act]");
  if (!btn) return;
  const i=parseInt(btn.getAttribute("data-i"),10);
  const act=btn.getAttribute("data-act");
  if (Number.isNaN(i)) return;

  if (act==="apply"){
    mountLinkIframe(i);
    applyLinkStyle(i);
    startLayerAuto(i);
  } else if (act==="rand"){
    const mode = linkLayers[i]?.ui?.randMode || "off";
    if (mode==="off"){
      $("status").textContent = `Status: Layer ${i+1} random is off`;
      return;
    }
    setLayerFromPlaylistRandom(i, mode);
  }
});

/* =========================
   Deck UI (thumbnails)
========================= */
let deckActiveKey = PLAYLISTS[0].key;

function rebuildDeckTabs(){
  const tabs = $("deckTabs");
  tabs.innerHTML = "";
  for (const p of PLAYLISTS){
    const b = document.createElement("button");
    b.textContent = p.name;
    b.dataset.key = p.key;
    b.className = (p.key===deckActiveKey) ? "active" : "";
    b.addEventListener("click", ()=>setDeckTab(p.key));
    tabs.appendChild(b);
  }
}

function updateDeckStatus(){
  const cached = playlistCache.get(deckActiveKey);
  if (!cached || !cached.items || !cached.items.length){
    $("deckStatus").textContent = "Deck: empty (try Refresh)";
    return;
  }
  $("deckStatus").textContent = `Deck: ${cached.items.length} videos loaded`;
}

function thumbUrl(videoId){
  return `https://i.ytimg.com/vi/${videoId}/hqdefault.jpg`;
}

async function setDeckTab(key){
  deckActiveKey = key;
  rebuildDeckTabs();
  await ensureDeckLoaded();
  renderDeck();
}

async function ensureDeckLoaded(){
  const cached = playlistCache.get(deckActiveKey);
  if (cached && cached.items && cached.items.length) return;
  $("deckStatus").textContent = "Deck: loading…";
  const data = await loadPlaylistItems(deckActiveKey);
  if (!data.items.length){
    $("deckStatus").textContent = "Deck: failed (Refresh)";
  }
}

function renderDeck(){
  updateDeckStatus();
  const grid = $("deckGrid");
  grid.innerHTML = "";

  const cached = playlistCache.get(deckActiveKey);
  const items = (cached && cached.items) ? cached.items : [];
  const q = ($("deckFilter").value||"").trim().toLowerCase();

  const filtered = q
    ? items.filter(it => (it.title||"").toLowerCase().includes(q) || it.id.includes(q))
    : items;

  // keep it performant
  const show = filtered.slice(0, 120);

  for (const it of show){
    const d = document.createElement("div");
    d.className = "thumb";
    d.title = it.title;

    const img = document.createElement("img");
    img.loading = "lazy";
    img.src = thumbUrl(it.id);

    const cap = document.createElement("div");
    cap.className = "cap";
    cap.textContent = it.title || it.id;

    d.appendChild(img);
    d.appendChild(cap);

    d.addEventListener("click", ()=>{
      const idx = parseInt($("deckTargetLayer").value, 10) || 0;
      const L = linkLayers[idx];
      if (!L) return;
      L.url = `https://www.youtube.com/watch?v=${it.id}`;
      mountLinkIframe(idx);
      applyLinkStyle(idx);
      rebuildLinkUI(false);
      $("status").textContent = `Status: Layer ${idx+1} ← deck (${deckActiveKey})`;
    });

    grid.appendChild(d);
  }

  if (!show.length){
    const empty = document.createElement("div");
    empty.className = "small";
    empty.textContent = "No matches.";
    grid.appendChild(empty);
  }
}

$("deckFilter").addEventListener("input", renderDeck);
$("deckRefresh").addEventListener("click", async ()=>{
  playlistCache.delete(deckActiveKey);
  $("deckStatus").textContent = "Deck: refreshing…";
  await ensureDeckLoaded();
  renderDeck();
});

/* =========================
   MODE 2: FX Capture + WebGL
========================= */
let capStreamA=null, capStreamB=null;
const capVideoA=document.createElement("video");
const capVideoB=document.createElement("video");
capVideoA.muted=true; capVideoB.muted=true;
capVideoA.playsInline=true; capVideoB.playsInline=true;

async function startCapture(which){
  try{
    const stream = await navigator.mediaDevices.getDisplayMedia({ video:{ frameRate:60 }, audio:false });
    if (which==="A"){ capStreamA=stream; capVideoA.srcObject=stream; await capVideoA.play(); }
    else { capStreamB=stream; capVideoB.srcObject=stream; await capVideoB.play(); }
    $("status").textContent = `Status: captured ${which}`;
    setMode("fx");
    $("fxOverlay").style.display = (!capStreamA && !capStreamB) ? "flex" : "none";
  }catch(e){
    $("status").textContent = `Status: capture ${which} canceled/blocked`;
  }
}
function stopCaptureAll(){
  for (const s of [capStreamA, capStreamB]){
    if (!s) continue;
    for (const tr of s.getTracks()) tr.stop();
  }
  capStreamA=null; capStreamB=null;
  capVideoA.srcObject=null; capVideoB.srcObject=null;
  $("status").textContent="Status: capture stopped";
  $("fxOverlay").style.display = (currentMode==="fx") ? "flex" : "none";
}
$("capA").addEventListener("click", ()=>startCapture("A"));
$("capB").addEventListener("click", ()=>startCapture("B"));
$("stopCap").addEventListener("click", stopCaptureAll);

$("fxAllOff").addEventListener("click", ()=>{
  $("tFeedback").checked=false; $("tKaleido").checked=false; $("tRGB").checked=false;
  $("tGlitch").checked=false; $("tPixel").checked=false; $("tScan").checked=false; $("tVig").checked=false;
});

/* Auto-fit crop to source aspect (best possible) */
function autoFit(which){
  const v = (which==="A") ? capVideoA : capVideoB;
  if (!v || !v.videoWidth || !v.videoHeight){
    $("status").textContent = `Status: ${which} not ready for auto-fit`;
    return;
  }
  const srcAR = v.videoWidth / v.videoHeight;
  const outAR = 16/9; // stage is 16:9
  let z = 1.0;
  if (srcAR > outAR) z = srcAR / outAR; else z = outAR / srcAR;
  if (which==="A") $("aZoom").value = z.toFixed(2);
  else $("bZoom").value = z.toFixed(2);
  $("status").textContent = `Status: auto-fit ${which} (zoom=${z.toFixed(2)})`;
}
$("fitA").addEventListener("click", ()=>autoFit("A"));
$("fitB").addEventListener("click", ()=>autoFit("B"));

/* =========================
   WebGL pipeline (targeted FX fixed)
========================= */
const canvas=$("fxOut");
let gl=null, prog=null, quadVBO=null;
let texA=null, texB=null;
let fbTex0=null, fbTex1=null, fbFbo0=null, fbFbo1=null, ping=0;

function createShader(gl,type,src){
  const sh=gl.createShader(type);
  gl.shaderSource(sh,src);
  gl.compileShader(sh);
  if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(sh));
    gl.deleteShader(sh); return null;
  }
  return sh;
}
function createProgram(gl,vsSrc,fsSrc){
  const vs=createShader(gl,gl.VERTEX_SHADER,vsSrc);
  const fs=createShader(gl,gl.FRAGMENT_SHADER,fsSrc);
  if(!vs||!fs) return null;
  const p=gl.createProgram();
  gl.attachShader(p,vs); gl.attachShader(p,fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    gl.deleteProgram(p); return null;
  }
  gl.deleteShader(vs); gl.deleteShader(fs);
  return p;
}
const VS=`
attribute vec2 aPos;
varying vec2 vUv;
void main(){ vUv=aPos*0.5+0.5; gl_Position=vec4(aPos,0.0,1.0); }
`;

const FS=`
precision highp float;
varying vec2 vUv;

uniform sampler2D uA;
uniform sampler2D uB;
uniform sampler2D uFB;
uniform vec2 uRes;
uniform float uTime;

uniform int uHasA;
uniform int uHasB;
uniform int uUseAasB;

uniform int uBlendMode;
uniform float uBOpacity;
uniform float uInvB;
uniform float uExposure;
uniform float uContrast;
uniform float uSat;

// Transform + crop per source
uniform int uAFlipH; uniform int uAFlipV; uniform int uARot;
uniform vec3 uACrop; // cx, cy, zoom
uniform int uBFlipH; uniform int uBFlipV; uniform int uBRot;
uniform vec3 uBCrop; // cx, cy, zoom

// FX toggles
uniform int uFeedbackOn;
uniform float uFbAmt;
uniform float uFbZoom;
uniform float uFbRot;

uniform int uKaleidoOn;
uniform float uKSeg;
uniform float uKAmt;
uniform float uKSpin;

uniform int uRGBOn;
uniform float uRGBAmt;

uniform int uGlitchOn;
uniform float uGlitchAmt;

uniform int uPixelOn;
uniform float uPixSize;

uniform int uScanOn;
uniform float uScanAmt;

uniform int uVigOn;
uniform float uVigAmt;

// FX targets: 0=A, 1=B, 2=Mix, 3=Final
uniform int uFeedbackT;
uniform int uKaleidoT;
uniform int uRGBT;
uniform int uGlitchT;
uniform int uPixelT;

vec3 satAdjust(vec3 c,float s){
  float l=dot(c,vec3(0.2126,0.7152,0.0722));
  return mix(vec3(l),c,s);
}
vec2 rot2(vec2 p,float a){
  float c=cos(a), s=sin(a);
  return mat2(c,-s,s,c)*p;
}
vec3 blend(vec3 a, vec3 b, int mode){
  if (mode==0) return b;                          // normal
  if (mode==1) return a*b;                        // multiply
  if (mode==2) return 1.0-(1.0-a)*(1.0-b);        // screen
  if (mode==3) return abs(a-b);                   // difference
  if (mode==4) return a+b;                        // add
  if (mode==5) return mix(2.0*a*b, 1.0-2.0*(1.0-a)*(1.0-b), step(0.5,a)); // overlay-ish
  if (mode==6) return a + b - 2.0*a*b;            // exclusion-ish
  return b;
}
float hash(vec2 p){
  p=fract(p*vec2(123.34,456.21));
  p+=dot(p,p+34.345);
  return fract(p.x*p.y);
}

vec2 applyRot(vec2 uv, int r){
  if (r==1) return vec2(uv.y, 1.0-uv.x);
  if (r==2) return vec2(1.0-uv.x, 1.0-uv.y);
  if (r==3) return vec2(1.0-uv.y, uv.x);
  return uv;
}
vec2 xfUv(vec2 uv, int flipH, int flipV, int rotQ){
  uv = applyRot(uv, rotQ);
  if (flipH==1) uv.x = 1.0-uv.x;
  if (flipV==1) uv.y = 1.0-uv.y;
  return clamp(uv,0.0,1.0);
}
vec2 cropUv(vec2 uv, vec3 c){
  float z = max(1.0, c.z);
  vec2 outUv = (uv - 0.5)/z + c.xy;
  return clamp(outUv, 0.0, 1.0);
}

vec3 sampleA(vec2 uv){
  if (uHasA!=1) return vec3(0.0);
  vec2 u = xfUv(uv, uAFlipH, uAFlipV, uARot);
  u = cropUv(u, uACrop);
  return texture2D(uA, u).rgb;
}
vec3 sampleB(vec2 uv){
  vec2 u = xfUv(uv, uBFlipH, uBFlipV, uBRot);
  u = cropUv(u, uBCrop);
  if (uHasB==1) return texture2D(uB, u).rgb;
  if (uUseAasB==1 && uHasA==1) {
    vec2 ua = xfUv(uv, uAFlipH, uAFlipV, uARot);
    ua = cropUv(ua, uBCrop);
    return texture2D(uA, ua).rgb;
  }
  return vec3(0.0);
}

vec3 computeMix(vec2 uv){
  vec3 A = sampleA(uv);
  vec3 B = sampleB(uv);
  B = mix(B, 1.0-B, clamp(uInvB,0.0,1.0));
  vec3 mixedB = blend(A,B,uBlendMode);
  return mix(A, mixedB, clamp(uBOpacity,0.0,1.0));
}

vec2 glitchUv(vec2 uv){
  float g=uGlitchAmt;
  float t=uTime*1.2;
  float line=floor(uv.y*240.0);
  float rnd=hash(vec2(line,floor(t*6.0)));
  vec2 guv = uv;
  guv.x += (rnd-0.5)*0.02*g;
  float blockY=floor(uv.y*10.0);
  float br=hash(vec2(blockY,floor(t*3.0)));
  if (br < 0.18*g) guv.x += (br-0.09)*0.12*g;
  return guv;
}

vec2 pixelUv(vec2 uv){
  float px=max(1.0,uPixSize);
  return floor(uv*px)/px + 0.5/px;
}

vec3 rgbShiftFromStage(int stage, vec2 uv){
  float amt = uRGBAmt;
  vec2 off = vec2(amt, 0.0);
  if (stage==0){
    vec3 c0 = sampleA(uv);
    vec3 cR = sampleA(uv+off);
    vec3 cB = sampleA(uv-off);
    return vec3(cR.r, c0.g, cB.b);
  }
  if (stage==1){
    vec3 c0 = sampleB(uv); c0 = mix(c0,1.0-c0,clamp(uInvB,0.0,1.0));
    vec3 cR = sampleB(uv+off); cR = mix(cR,1.0-cR,clamp(uInvB,0.0,1.0));
    vec3 cB = sampleB(uv-off); cB = mix(cB,1.0-cB,clamp(uInvB,0.0,1.0));
    return vec3(cR.r, c0.g, cB.b);
  }
  if (stage==2){
    vec3 c0 = computeMix(uv);
    vec3 cR = computeMix(uv+off);
    vec3 cB = computeMix(uv-off);
    return vec3(cR.r, c0.g, cB.b);
  }
  // stage==3 (Final pre-post): same as mix (feedback/kaleido may modify later)
  vec3 c0 = computeMix(uv);
  vec3 cR = computeMix(uv+off);
  vec3 cB = computeMix(uv-off);
  return vec3(cR.r, c0.g, cB.b);
}

void main(){
  vec2 uv = vUv;

  // Start with base stages
  vec3 A = sampleA(uv);
  vec3 B = sampleB(uv); B = mix(B, 1.0-B, clamp(uInvB,0.0,1.0));
  vec3 Mix = computeMix(uv);
  vec3 Final = Mix;

  // Glitch targeted (recompute the targeted stage from glitched UV)
  if (uGlitchOn==1){
    vec2 guv = glitchUv(uv);
    if (uGlitchT==0) { A = sampleA(guv); }
    else if (uGlitchT==1) { B = sampleB(guv); B = mix(B,1.0-B,clamp(uInvB,0.0,1.0)); }
    else if (uGlitchT==2) { Mix = computeMix(guv); Final = Mix; }
    else { Final = computeMix(guv); } // Final target (pre feedback/kaleido)
  }

  // Pixelate targeted (recompute from pixel UV)
  if (uPixelOn==1){
    vec2 puv = pixelUv(uv);
    if (uPixelT==0) { A = sampleA(puv); }
    else if (uPixelT==1) { B = sampleB(puv); B = mix(B,1.0-B,clamp(uInvB,0.0,1.0)); }
    else if (uPixelT==2) { Mix = computeMix(puv); Final = Mix; }
    else { Final = computeMix(puv); }
  }

  // RGB targeted (recompute targeted stage with channel offset)
  if (uRGBOn==1){
    if (uRGBT==0) A = rgbShiftFromStage(0, uv);
    else if (uRGBT==1) B = rgbShiftFromStage(1, uv);
    else if (uRGBT==2) { Mix = rgbShiftFromStage(2, uv); Final = Mix; }
    else { Final = rgbShiftFromStage(3, uv); }
  }

  // After any re-targeting above, rebuild Mix/Final if A or B changed but Mix targeted wasn't selected
  // (keeps things intuitive)
  // If user targeted A or B, update Mix from current A/B at same uv
  if (uGlitchOn==1 || uPixelOn==1 || uRGBOn==1){
    if (uGlitchT==0 || uGlitchT==1 || uPixelT==0 || uPixelT==1 || uRGBT==0 || uRGBT==1){
      vec3 mixedB = blend(A,B,uBlendMode);
      Mix = mix(A, mixedB, clamp(uBOpacity,0.0,1.0));
      Final = Mix;
    }
  }

  // Feedback (targeted) uses previous framebuffer
  if (uFeedbackOn==1){
    vec2 p = vUv - 0.5;
    vec2 fbUv = rot2(p, uFbRot) / (1.0 + uFbZoom) + 0.5;
    vec3 fb = texture2D(uFB, fbUv).rgb;
    float amt = clamp(uFbAmt,0.0,0.98);
    if (uFeedbackT==0) A = mix(A, fb, amt);
    else if (uFeedbackT==1) B = mix(B, fb, amt);
    else if (uFeedbackT==2) Final = mix(Mix, fb, amt);
    else Final = mix(Final, fb, amt);

    // if feedback hit A/B, rebuild mix/final
    if (uFeedbackT==0 || uFeedbackT==1){
      vec3 mixedB = blend(A,B,uBlendMode);
      Mix = mix(A, mixedB, clamp(uBOpacity,0.0,1.0));
      Final = Mix;
    }
  }

  // Kaleido (targeted) recomputes the targeted stage from kaleido UV
  if (uKaleidoOn==1){
    vec2 kp = vUv - 0.5;
    float ang = atan(kp.y,kp.x);
    float r = length(kp);
    float seg = max(2.0, uKSeg);
    float k = 6.28318530718/seg;
    ang = mod(ang + uTime*uKSpin, k);
    ang = abs(ang - k*0.5);
    vec2 ku = vec2(cos(ang), sin(ang))*r;
    vec2 uvk = ku + 0.5;

    float amt = clamp(uKAmt,0.0,1.0);
    if (uKaleidoT==0){
      vec3 kA = sampleA(uvk);
      A = mix(A, kA, amt);
    } else if (uKaleidoT==1){
      vec3 kB = sampleB(uvk); kB = mix(kB, 1.0-kB, clamp(uInvB,0.0,1.0));
      B = mix(B, kB, amt);
    } else if (uKaleidoT==2){
      vec3 kMix = computeMix(uvk);
      Final = mix(Mix, kMix, amt);
    } else {
      vec3 kF = computeMix(uvk);
      Final = mix(Final, kF, amt);
    }

    // if kaleido hit A/B, rebuild mix/final
    if (uKaleidoT==0 || uKaleidoT==1){
      vec3 mixedB = blend(A,B,uBlendMode);
      Mix = mix(A, mixedB, clamp(uBOpacity,0.0,1.0));
      Final = Mix;
    }
  }

  // Color controls on final
  Final *= uExposure;
  Final = (Final - 0.5)*uContrast + 0.5;
  Final = satAdjust(Final, uSat);

  if (uScanOn==1){
    float s = sin(vUv.y*uRes.y*3.14159);
    float scan = mix(1.0, 0.78 + 0.22*s, clamp(uScanAmt,0.0,1.0));
    Final *= scan;
  }
  if (uVigOn==1){
    float d = distance(vUv, vec2(0.5));
    float v = smoothstep(0.35, 0.95, d);
    Final *= mix(1.0, 1.0 - v, clamp(uVigAmt,0.0,1.0));
  }

  gl_FragColor = vec4(clamp(Final,0.0,1.0), 1.0);
}
`;

function resizeCanvas(){
  const dpr=Math.min(2, window.devicePixelRatio||1);
  const rect=canvas.getBoundingClientRect();
  const w=Math.max(2, Math.floor(rect.width*dpr));
  const h=Math.max(2, Math.floor(rect.height*dpr));
  if (canvas.width!==w || canvas.height!==h){
    canvas.width=w; canvas.height=h;
    if (gl){
      gl.viewport(0,0,w,h);
      initFeedbackTextures(w,h);
    }
  }
}
function makeTex(){
  const t=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.bindTexture(gl.TEXTURE_2D,null);
  return t;
}
function initFeedbackTextures(w,h){
  function makeFBTex(){
    const t=makeTex();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    gl.bindTexture(gl.TEXTURE_2D,null);
    return t;
  }
  function makeFBO(tex){
    const f=gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,f);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.bindFramebuffer(gl.FRAMEBUFFER,null);
    return f;
  }
  [fbTex0,fbTex1].forEach(t=>t&&gl.deleteTexture(t));
  [fbFbo0,fbFbo1].forEach(f=>f&&gl.deleteFramebuffer(f));
  fbTex0=makeFBTex(); fbTex1=makeFBTex();
  fbFbo0=makeFBO(fbTex0); fbFbo1=makeFBO(fbTex1);
  ping=0;
}
function initGL(){
  gl = canvas.getContext("webgl", {antialias:false, alpha:false});
  if (!gl){ $("status").textContent="Status: WebGL not supported"; return; }
  prog = createProgram(gl, VS, FS);
  if (!prog){ $("status").textContent="Status: shader compile failed"; return; }
  gl.useProgram(prog);

  quadVBO = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadVBO);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

  const aPos = gl.getAttribLocation(prog,"aPos");
  gl.enableVertexAttribArray(aPos);
  gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

  texA=makeTex(); texB=makeTex();
  resizeCanvas();
}

function blendModeToInt(v){
  if (v==="normal") return 0;
  if (v==="multiply") return 1;
  if (v==="screen") return 2;
  if (v==="difference") return 3;
  if (v==="add") return 4;
  if (v==="overlay") return 5;
  if (v==="exclusion") return 6;
  return 3;
}
function targetToInt(v){
  if (v==="a") return 0;
  if (v==="b") return 1;
  if (v==="mix") return 2;
  return 3; // final
}
function rotToQ(v){
  const n = parseInt(v,10) || 0;
  if (n===90) return 1;
  if (n===180) return 2;
  if (n===270) return 3;
  return 0;
}
function updateVideoTexture(tex, video){
  gl.bindTexture(gl.TEXTURE_2D, tex);
  try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,video); }catch(e){}
  gl.bindTexture(gl.TEXTURE_2D, null);
}

function tick(t){
  if (gl && currentMode==="fx"){
    resizeCanvas();
    const hasA = !!capStreamA && capVideoA.readyState>=2;
    const hasB = !!capStreamB && capVideoB.readyState>=2;

    $("fxOverlay").style.display = (!hasA && !hasB) ? "flex" : "none";

    if (hasA) updateVideoTexture(texA, capVideoA);
    if (hasB) updateVideoTexture(texB, capVideoB);

    gl.useProgram(prog);
    const w=canvas.width, h=canvas.height;

    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texA);
    gl.uniform1i(gl.getUniformLocation(prog,"uA"), 0);

    gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texB);
    gl.uniform1i(gl.getUniformLocation(prog,"uB"), 1);

    const prevTex = (ping===0) ? fbTex0 : fbTex1;
    const nextFbo = (ping===0) ? fbFbo1 : fbFbo0;

    gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, prevTex);
    gl.uniform1i(gl.getUniformLocation(prog,"uFB"), 2);

    gl.uniform2f(gl.getUniformLocation(prog,"uRes"), w, h);
    gl.uniform1f(gl.getUniformLocation(prog,"uTime"), t/1000);

    gl.uniform1i(gl.getUniformLocation(prog,"uHasA"), hasA?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uHasB"), hasB?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uUseAasB"), $("useAasB").checked ? 1 : 0);

    gl.uniform1i(gl.getUniformLocation(prog,"uBlendMode"), blendModeToInt($("fxBlend").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uBOpacity"), parseFloat($("fxBOpacity").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uInvB"), parseFloat($("fxInvB").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uExposure"), parseFloat($("fxExposure").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uContrast"), parseFloat($("fxContrast").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uSat"), parseFloat($("fxSat").value));

    // transforms
    gl.uniform1i(gl.getUniformLocation(prog,"uAFlipH"), $("aFlipH").checked?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uAFlipV"), $("aFlipV").checked?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uARot"), rotToQ($("aRot").value));
    gl.uniform3f(gl.getUniformLocation(prog,"uACrop"),
      parseFloat($("aCx").value), parseFloat($("aCy").value), parseFloat($("aZoom").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uBFlipH"), $("bFlipH").checked?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uBFlipV"), $("bFlipV").checked?1:0);
    gl.uniform1i(gl.getUniformLocation(prog,"uBRot"), rotToQ($("bRot").value));
    gl.uniform3f(gl.getUniformLocation(prog,"uBCrop"),
      parseFloat($("bCx").value), parseFloat($("bCy").value), parseFloat($("bZoom").value));

    // FX toggles
    gl.uniform1i(gl.getUniformLocation(prog,"uFeedbackOn"), $("tFeedback").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uFbAmt"), parseFloat($("feedbackAmt").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uFbZoom"), parseFloat($("feedbackZoom").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uFbRot"), parseFloat($("feedbackRot").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uKaleidoOn"), $("tKaleido").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uKSeg"), parseFloat($("kSeg").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uKAmt"), parseFloat($("kAmt").value));
    gl.uniform1f(gl.getUniformLocation(prog,"uKSpin"), parseFloat($("kSpin").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uRGBOn"), $("tRGB").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uRGBAmt"), parseFloat($("rgbAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uGlitchOn"), $("tGlitch").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uGlitchAmt"), parseFloat($("glitchAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uPixelOn"), $("tPixel").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uPixSize"), parseFloat($("pixSize").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uScanOn"), $("tScan").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uScanAmt"), parseFloat($("scanAmt").value));

    gl.uniform1i(gl.getUniformLocation(prog,"uVigOn"), $("tVig").checked?1:0);
    gl.uniform1f(gl.getUniformLocation(prog,"uVigAmt"), parseFloat($("vigAmt").value));

    // FX targets
    gl.uniform1i(gl.getUniformLocation(prog,"uFeedbackT"), targetToInt($("feedbackTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uKaleidoT"), targetToInt($("kaleidoTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uRGBT"), targetToInt($("rgbTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uGlitchT"), targetToInt($("glitchTarget").value));
    gl.uniform1i(gl.getUniformLocation(prog,"uPixelT"), targetToInt($("pixelTarget").value));

    // render to feedback
    gl.bindFramebuffer(gl.FRAMEBUFFER, nextFbo);
    gl.viewport(0,0,w,h);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // swap
    ping = 1-ping;
    const nowTex = (ping===0) ? fbTex0 : fbTex1;

    // render to screen using updated feedback tex
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, nowTex);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,w,h);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  requestAnimationFrame(tick);
}

/* =========================
   Slider numeric readouts
========================= */
function refreshValBadges(){
  document.querySelectorAll("[data-valfor]").forEach(el=>{
    const id = el.getAttribute("data-valfor");
    const inp = document.getElementById(id);
    if (!inp) return;
    el.textContent = inp.value;
  });
}
document.addEventListener("input", (e)=>{
  const t = e.target;
  if (t && t.id){
    const badge = document.querySelector(`[data-valfor="${t.id}"]`);
    if (badge) badge.textContent = t.value;
  }
});


function resizeOnWindow(){ resizeCanvas(); }
window.addEventListener("resize", resizeOnWindow);

document.addEventListener("DOMContentLoaded", async ()=>{
  initGL();
  rebuildLinkLayers();
  setMode("links");
  refreshValBadges();
  requestAnimationFrame(tick);

  // pre-load first deck
  await ensureDeckLoaded();
  renderDeck();
});
</script>
</body>
</html>
